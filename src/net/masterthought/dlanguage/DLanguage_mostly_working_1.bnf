{

  parserClass="net.masterthought.dlanguage.parser.DLanguageParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="DLanguage"
  psiImplClassSuffix="Impl"
  psiPackage="net.masterthought.dlanguage.psi"
  psiImplPackage="net.masterthought.dlanguage.psi.impl"

  elementTypeHolderClass="net.masterthought.dlanguage.psi.DLanguageTypes"
  elementTypeClass="net.masterthought.dlanguage.psi.DLanguageElementType"
  tokenTypeClass="net.masterthought.dlanguage.psi.DLanguageTokenType"

  generateTokenAccessors=true

tokens = [
 KW_MODULE = "module"
 KW_IMPORT = "import"
 KW_STATIC = "static"
 KW_BOOL = "bool"
 KW_BYTE = "byte"
 KW_UBYTE = "ubyte"
 KW_SHORT = "short"
 KW_USHORT = "ushort"
 KW_INT = "int"
 KW_UINT = "uint"
 KW_LONG = "long"
 KW_ULONG = "ulong"
 KW_CHAR = "char"
 KW_WCHAR = "wchar"
 KW_DCHAR = "dchar"
 KW_FLOAT = "float"
 KW_DOUBLE = "double"
 KW_REAL = "real"
 KW_IFLOAT = "ifloat"
 KW_IDOUBLE = "idouble"
 KW_IREAL = "ireal"
 KW_CFLOAT = "cfloat"
 KW_CDOUBLE = "cdouble"
 KW_CREAL = "creal"
 KW_VOID = "void"
 KW_TYPEOF = "typeof"
 KW_CONST = "const"
 KW_IMMUTABLE = "immutable"
 KW_SHARED = "shared"
 KW_INOUT = "inout"
 KW_DELEGATE = "delegate"
 KW_FUNCTION = "function"
 KW_NOTHROW = "nothrow"
 KW_PURE = "pure"
 KW_THIS = "this"
 KW___FILE__ = "__FILE__"
 KW___MODULE__ = "__MODULE__"
 KW___LINE__ = "__LINE__"
 KW___FUNCTION__ = "__FUNCTION__"
 KW___PRETTY_FUNCTION__ = "__PRETTY_FUNCTION__"
 KW_ABSTRACT = "abstract"
 KW_ALIAS = "alias"
 KW_AUTO = "auto"
 KW_DEPRECATED = "deprecated"
 KW_ENUM = "enum"
 KW_EXTERN = "extern"
 KW_FINAL = "final"
 KW_OVERRIDE = "override"
 KW___GSHARED = "__gshared"
 KW_SCOPE = "scope"
 KW_SYNCHRONIZED = "synchronized"
 KW_RETURN = "return"
 KW_SUPER = "super"
 KW_ALIGN = "align"
 KW_PRAGMA = "pragma"
 KW_PACKAGE = "package"
 KW_PRIVATE = "private"
 KW_PROTECTED = "protected"
 KW_PUBLIC = "public"
 KW_EXPORT = "export"
 KW_PROPERTY = "property"
 KW_SAFE = "safe"
 KW_TRUSTED = "trusted"
 KW_SYSTEM = "system"
 KW_DISABLE = "disable"
 KW_DELETE = "delete"
 KW_NULL = "null"
 KW_TRUE = "true"
 KW_FALSE = "false"
 KW_NEW = "new"
 KW_TYPEID = "typeid"
 KW_IS = "is"
 KW_STRUCT = "struct"
 KW_UNION = "union"
 KW_CLASS = "class"
 KW_INTERFACE = "interface"
 KW___PARAMETERS = "__parameters"
 KW_IN = "in"
 KW_ASM = "asm"
 KW_ASSERT = "assert"
 KW_CASE = "case"
 KW_CAST = "cast"
 KW_REF = "ref"
 KW_BREAK = "break"
 KW_CONTINUE = "continue"
 KW_DO = "do"
 KW_ELSE = "else"
 KW_FOR = "for"
 KW_FOREACH = "foreach"
 KW_FOREACH_REVERSE = "foreach_reverse"
 KW_GOTO = "goto"
 KW_IF = "if"
 KW_CATCH = "catch"
 KW_FINALLY = "finally"
 KW_SWITCH = "switch"
 KW_THROW = "throw"
 KW_TRY = "try"
 KW_DEFAULT = "default"
 KW_WHILE = "while"
 KW_WITH = "with"
 KW_VERSION = "version"
 KW_DEBUG = "debug"
 KW_MIXIN = "mixin"
 KW_INVARIANT = "invariant"
 KW_BODY = "body"
 KW_TEMPLATE = "template"
 KW_LAZY = "lazy"
 KW_OUT = "out"
 KW_NOGC = "nogc"
 KW___TRAITS = "__traits"
 KW_UNITTEST = "unittest"
 OP_SCOLON = ";"
 OP_COLON = ":"
 OP_EQ = "="
 OP_COMMA = ","
 OP_PAR_LEFT = "("
 OP_PAR_RIGHT = ")"
 OP_BRACKET_LEFT = "["
 OP_BRACKET_RIGHT = "]"
 OP_BRACES_LEFT = "{"
 OP_BRACES_RIGHT = "}"
 OP_ASTERISK = "*"
 OP_DDOT = ".."
 OP_TRIPLEDOT = "..."
 OP_AT = "@"
 OP_PLUS_EQ = "+="
 OP_MINUS_EQ = "-="
 OP_MUL_EQ = "*="
 OP_DIV_EQ = "/="
 OP_MOD_EQ = "%="
 OP_AND_EQ = "&="
 OP_OR_EQ = "|="
 OP_XOR_EQ = "^="
 OP_TILDA_EQ = "~="
 OP_SH_LEFT_EQ = "<<="
 OP_SH_RIGHT_EQ = ">>="
 OP_USH_RIGHT_EQ = ">>>="
 OP_POW_EQ = "^^="
 OP_QUEST = "?"
 OP_BOOL_OR = "||"
 OP_BOOL_AND = "&&"
 OP_OR = "|"
 OP_XOR = "^"
 OP_SH_LEFT = "<<"
 OP_SH_RIGHT = ">>"
 OP_USH_RIGHT = ">>>"
 OP_PLUS = "+"
 OP_MINUS = "-"
 OP_TILDA = "~"
 OP_DIV = "/"
 OP_MOD = "%"
 OP_AND = "&"
 OP_PLUS_PLUS = "++"
 OP_MINUS_MINUS = "--"
 OP_NOT = "!"
 OP_POW = "^^"
 OP_DOLLAR = "$"
 OP_EQ_EQ = "=="
 OP_NOT_EQ = "!="
 OP_LESS = "<"
 OP_LESS_EQ = "<="
 OP_GT = ">"
 OP_GT_EQ = ">="
 OP_UNORD = "!<>="
 OP_UNORD_EQ = "!<>"
 OP_LESS_GR = "<>"
 OP_LESS_GR_EQ = "<>="
 OP_NOT_GR = "!>"
 OP_NOT_GR_EQ = "!>="
 OP_NOT_LESS = "!<"
 OP_NOT_LESS_EQ = "!<="
 OP_LAMBDA_ARROW = "=>"
 OP_DOT = "."

ID = "regexp:\w+"

  space='regexp:\s+'

//  string_literal='regexp:"\w+"'
//  string="regexp:('([^'\\]|\\.)*'|\"([^\"\\]|\\\"|\\\'|\\)*\")"
//  number="regexp:\d+"
//  float="regexp:[-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?"
  line_comment="regexp://.*"
  block_comment="regexp:/\*(.|\n)*\*/"

//   DoubleQuotedString = 'regexp:\"([^\\"]|((\\"|\\\?|\\\|\\0|\\a|\\b|\\f|\\n|\\r|\\t|\\v)|(\\x[0-9abcdefABCDEF_]{2})|(\\[0-7])|(\\[0-7]{2})|(\\[0-7]{3})|(\\u[0-9abcdefABCDEF_]{4})|(\\U[0-9abcdefABCDEF_]{8})|(\\&([a-zA-Z_])([a-zA-Z0-9_])*;)))*\"[cwd]*'
  //  HexString = 'regexp:x\"([0-9a-fA-F][0-9a-fA-F]|[\r\n\s])*\"[cwd]*'


]


}

dFile ::= item_*

// ----------------------------------------------------------





 // orOrExpression ::=
 //       andAndExpression
 //     | orOrExpression '||' andAndExpression

// orOrExpression ::= andAndExpression ['||' orOrExpression]


asmBrExp ::= asmUnaExp | asmBrExp? '[' asmExp ']'

asmOrExp ::= asmXorExp | asmOrExp '|' asmXorExp

asmXorExp ::= asmAndExp | asmXorExp '^' asmAndExp

//indexExpression ::= unaryExpression '[' argumentList ']'

operands ::= asmExp | asmExp ',' operands

//sliceExpression ::= unaryExpression '[' assignExpression '..' assignExpression ']' | unaryExpression '[' ']'

unaryExpression ::= primaryExpression+
| '&' unaryExpression
| '!' unaryExpression
| '*' unaryExpression
| '+' unaryExpression
| '-' unaryExpression
| '~' unaryExpression
| '++' unaryExpression+
| '--' unaryExpression+
| newExpression
| deleteExpression
| castExpression
| assertExpression
| functionCallExpression
//| sliceExpression
//| indexExpression
| '(' type ')' '.' identifierOrTemplateInstance
//| unaryExpression '.' identifierOrTemplateInstance
//| unaryExpression '--'
//| unaryExpression '++'


// unused --------------

//postblit ::= 'this' '(' 'this' ')' memberFunctionAttribute* ( functionBody | ';' )

// ---------------------------------------------------------
private item_ ::= ( moduleDeclaration | declaration | statement )

  Identifier ::= ID
  StringLiteral  ::= (WYSIWYG_STRING|ALTERNATE_WYSIWYG_STRING|DOUBLE_QUOTED_STRING|HEX_STRING|DELIMITED_STRING)

 moduleDeclaration ::= deprecated? 'module' identifierChain ';'
 
  deprecated ::= 'deprecated' ( '(' StringLiteral ')' )?
 
  identifierChain ::= Identifier ( '.' Identifier )*

   asmMulExp ::= asmBrExp [( '*' | '/' | '%' ) asmMulExp]

 importBind ::= Identifier ( '=' Identifier )?

 importBindings ::= singleImport ':' importBind ( ',' importBind )*

  asmAndExp ::= asmEqualExp ['&' asmAndExp]
   asmAddExp ::= asmMulExp [( '+' | '-' ) asmAddExp]

 lambdaExpression ::= Identifier '=>' assignExpression | 'function' type? parameters functionAttribute* '=>' assignExpression | 'delegate' type? parameters functionAttribute* '=>' assignExpression | parameters functionAttribute* '=>' assignExpression

  importDeclaration ::=
        'import' singleImport (',' singleImport)* (',' importBindings)? ';'
      | 'import' importBindings ';'

 singleImport ::= ( Identifier '=' )? identifierChain
 
importExpression ::= 'import' '(' assignExpression ')'

 asmLogOrExp ::= asmLogAndExp [ '||' asmLogOrExp ]

 addExpression ::= mulExpression [('+' | '-' | '~') addExpression]

aliasDeclaration ::= 'alias' aliasInitializer ( ',' aliasInitializer )* ';' | 'alias' storageClass* type identifierList ';'

aliasInitializer ::= Identifier templateParameters? '=' storageClass* type

aliasThisDeclaration ::= 'alias' Identifier 'this' ';'

alignAttribute ::= 'align' ( '(' INTEGER_LITERAL ')' )?

 andAndExpression ::= orExpression ['&&' andAndExpression]

  andExpression ::= cmpExpression ['&' andExpression]

argumentList ::= assignExpression ( ',' assignExpression? )*

arguments ::= '(' argumentList? ')'

arrayInitializer ::= '[' ']' | '[' arrayMemberInitialization ( ',' arrayMemberInitialization? )* ']'

arrayLiteral ::= '[' argumentList? ']'

arrayMemberInitialization ::= ( assignExpression ':' )? nonVoidInitializer



asmEqualExp ::= asmRelExp | ('==' | '!=') asmRelExp

asmExp ::= asmLogOrExp ( '?' asmExp ':' asmExp )?

asmInstruction ::= Identifier | 'align' INTEGER_LITERAL | 'align' Identifier | Identifier ':' asmInstruction | Identifier operands | 'in' operands | 'out' operands | 'int' operands

asmLogAndExp ::= asmOrExp asmLogAndExp '&&' asmOrExp

 castExpression ::= 'cast' '(' ( type | castQualifier )? ')' unaryExpression

 deleteExpression ::= 'delete' unaryExpression

functionCallExpression ::= symbol arguments unaryExpression arguments | type arguments

asmPrimaryExp ::= INTEGER_LITERAL | FLOAT_LITERAL | StringLiteral | register | identifierChain | '$'

 asmRelExp ::=
     asmShiftExp (('<' | '<=' | '>' | '>=') asmShiftExp)?

 asmShiftExp ::=
     asmAddExp (('<<' | '>>' | '>>>') asmAddExp)?

asmStatement ::=
     'asm' '{' asmInstruction+ '}'

asmTypePrefix ::= Identifier Identifier? | 'byte' Identifier? | 'short' Identifier? | 'int' Identifier? | 'float' Identifier? | 'double' Identifier? | 'real' Identifier?

asmUnaExp ::= asmTypePrefix asmExp | Identifier asmExp | '+' asmUnaExp | '-' asmUnaExp | '!' asmUnaExp | '~' asmUnaExp | asmPrimaryExp



assertExpression ::= 'assert' '(' assignExpression ( ',' assignExpression )? ')'

assignExpression ::= ternaryExpression ( assignOperator expression )?

 assignOperator ::=
       '='
     | '>>>='
     | '>>='
     | '<<='
     | '+='
     | '-='
     | '*='
     | '%='
     | '&='
     | '/='
     | '|='
     | '^^='
     | '^='
     | '~='

assocArrayLiteral ::= '[' keyValuePairs ']'

atAttribute ::= '@' Identifier | '@' Identifier '(' argumentList? ')' | '@' '(' argumentList ')'

attribute ::=
 pragmaExpression
| alignAttribute
| deprecated
| atAttribute
| linkageAttribute
| 'export'
| 'package'
| 'private'
| 'protected'
| 'public'
| 'static'
| 'extern'
| 'abstract'
| 'final'
| 'override'
| 'synchronized'
| 'auto'
| 'scope'
| 'const'
| 'immutable'
| 'inout'
| 'shared'
| '_gshared'
| 'nothrow'
| 'pure'
| 'ref'

attributeDeclaration ::= attribute ':'

autoDeclaration ::= storageClass Identifier '=' initializer ( ',' Identifier '=' initializer )* ';'

blockStatement ::= '{' declarationsAndStatements? '}'

bodyStatement ::= 'body' blockStatement

breakStatement ::= 'break' Identifier? ';'

baseClass ::= type2

baseClassList ::= baseClass ( ',' baseClass )*

builtinType ::= 'bool' | 'byte' | 'ubyte' | 'short' | 'ushort' | 'int' | 'uint' | 'long' | 'ulong' | 'char' | 'wchar' | 'dchar' | 'float' | 'double' | 'real' | 'ifloat' | 'idouble' | 'ireal' | 'cfloat' | 'cdouble' | 'creal' | 'void'

caseRangeStatement ::= 'case' assignExpression ':' '...' 'case' assignExpression ':' declarationsAndStatements

caseStatement ::= 'case' argumentList ':' declarationsAndStatements



castQualifier ::= 'const' | 'const' 'shared' | 'immutable' | 'inout' | 'inout' 'shared' | 'shared' | 'shared' 'const' | 'shared' 'inout'

catch_ ::= 'catch' '(' type Identifier? ')' declarationOrStatement

catches ::= catch_+ | catch_* lastCatch

classDeclaration ::= 'class' Identifier ';' | 'class' Identifier ( ':' baseClassList )? structBody | 'class' Identifier templateParameters constraint? ( structBody | ';' ) | 'class' Identifier templateParameters constraint? ( ':' baseClassList )? structBody | 'class' Identifier templateParameters ( ':' baseClassList )? constraint? structBody

cmpExpression ::= 
shiftExpression
| equalExpression
| identityExpression 
| relExpression 
| inExpression

compileCondition ::= versionCondition | debugCondition | staticIfCondition

conditionalDeclaration ::= compileCondition declaration | compileCondition ':' declaration | compileCondition declaration 'else' declaration

conditionalStatement ::= compileCondition declarationOrStatement ( 'else' declarationOrStatement )?

constraint ::= 'if' '(' expression ')'

constructor ::= 'this' templateParameters? parameters memberFunctionAttribute* constraint? ( functionBody | ';' )

continueStatement ::= 'continue' Identifier? ';'

debugCondition ::= 'debug' ( '(' ( INTEGER_LITERAL | Identifier ) ')' )?

debugSpecification ::= 'debug' '=' ( Identifier | INTEGER_LITERAL ) ';'

declaration ::= attribute* declaration2

declaration2 ::= aliasDeclaration
| aliasThisDeclaration
| anonymousEnumDeclaration
| attributeDeclaration
| classDeclaration
| conditionalDeclaration
| constructor
| debugSpecification
| destructor
| enumDeclaration
| eponymousTemplateDeclaration
| functionDeclaration
| importDeclaration
| interfaceDeclaration
| invariant
| mixinDeclaration
| mixinTemplateDeclaration
| pragmaDeclaration
| sharedStaticConstructor
| sharedStaticDestructor
| staticAssertDeclaration
| staticConstructor
| staticDestructor
| structDeclaration
| templateDeclaration
| unionDeclaration
| unittest
| variableDeclaration
| versionSpecification
| '{' declaration '}'


declarationsAndStatements ::= declarationOrStatement+

declarationOrStatement ::= declaration | statement

declarator ::=
     Identifier ('=' initializer)?

defaultStatement ::= 'default' ':' declarationsAndStatements




destructor ::= '~' 'this' '(' ')' memberFunctionAttribute* ( functionBody | ';' )

doStatement ::= 'do' statementNoCaseNoDefault 'while' '(' expression ')' ';'

enumBody ::= '{' enumMember ( ',' enumMember? )* '}'

anonymousEnumMember ::= type Identifier '=' assignExpression | Identifier '=' assignExpression | Identifier

anonymousEnumDeclaration ::= 'enum' ( ':' type )? '{' anonymousEnumMember '}'

enumDeclaration ::= 'enum' Identifier ( ':' type )? ';' | 'enum' Identifier ( ':' type )? enumBody

enumMember ::= Identifier | Identifier '=' assignExpression

eponymousTemplateDeclaration ::= 'enum' Identifier templateParameters '=' assignExpression ';'

equalExpression ::= shiftExpression ( '==' | '!=' ) shiftExpression

expression ::= assignExpression ( ',' assignExpression )*

expressionStatement ::= expression ';'

finalSwitchStatement ::= 'final' switchStatement

finally_ ::= 'finally' declarationOrStatement

forStatement ::= 'for' '(' ( declaration | statementNoCaseNoDefault ) expression? ';' expression? ')' declarationOrStatement

foreachStatement ::= ( 'foreach' | 'foreach_reverse' ) '(' foreachTypeList ';' expression ')' declarationOrStatement | ( 'foreach' | 'foreach_reverse' ) '(' foreachType ';' expression '..' expression ')' declarationOrStatement

foreachType ::= 'ref'? typeConstructors? type? Identifier | typeConstructors? 'ref'? type? Identifier

foreachTypeList ::= foreachType ( ',' foreachType )*

functionAttribute ::= atAttribute | 'pure' | 'nothrow'

functionBody ::= blockStatement | ( inStatement | outStatement | outStatement inStatement | inStatement outStatement )? bodyStatement



functionDeclaration ::= ( storageClass | type ) Identifier parameters memberFunctionAttribute* ( functionBody | ';' )
| ( storageClass | type ) Identifier templateParameters parameters memberFunctionAttribute* constraint? ( functionBody | ';' )

functionLiteralExpression ::= ( ( 'function' | 'delegate' ) type? )? ( parameters functionAttribute* )? functionBody

gotoStatement ::= 'goto' ( Identifier | 'default' | 'case' expression? ) ';'



identifierList ::= Identifier ( ',' Identifier )*

identifierOrTemplateChain ::= identifierOrTemplateInstance ( '.' identifierOrTemplateInstance )*

identifierOrTemplateInstance ::= Identifier | templateInstance

identityExpression ::= shiftExpression ( 'is' | ( '!' 'is' ) ) shiftExpression

ifStatement ::= 'if' '(' ifCondition ')' declarationOrStatement ( 'else' declarationOrStatement )?

ifCondition ::= 'auto' Identifier '=' expression
  | type Identifier '=' expression
  | expression





inExpression ::= shiftExpression ( 'in' | ( '!' 'in' ) ) shiftExpression

inStatement ::= 'in' blockStatement

initializer ::= 'void' | nonVoidInitializer

interfaceDeclaration ::= 'interface' Identifier ';' | 'interface' Identifier ( ':' baseClassList )? structBody | 'interface' Identifier templateParameters constraint? ( ':' baseClassList )? structBody | 'interface' Identifier templateParameters ( ':' baseClassList )? constraint? structBody

invariant ::= 'invariant' ( '(' ')' )? blockStatement

isExpression ::= 'is' '(' type Identifier? ')' 'is' '(' type Identifier? ':' typeSpecialization ')' 'is' '(' type Identifier? '=' typeSpecialization ')' 'is' '(' type Identifier? ':' typeSpecialization ',' templateParameterList ')' 'is' '(' type Identifier? '=' typeSpecialization ',' templateParameterList ')'

keyValuePair ::= assignExpression ':' assignExpression

keyValuePairs ::= keyValuePair ( ',' keyValuePair )* ','?

labeledStatement ::= Identifier ':' declarationOrStatement?


lastCatch ::= 'catch' statementNoCaseNoDefault

linkageAttribute ::= 'extern' '(' Identifier ( '++' ( ',' identifierChain )? )? ')'

memberFunctionAttribute ::= functionAttribute | 'immutable' | 'inout' | 'shared' | 'const' | 'return'

mixinDeclaration ::= mixinExpression ';' | templateMixinExpression ';'

mixinExpression ::= 'mixin' '(' assignExpression ')'

mixinTemplateDeclaration ::= 'mixin' templateDeclaration

mixinTemplateName ::= symbol | typeofExpression '.' identifierOrTemplateChain



  mulExpression ::= powExpression [('*' | '/' | '%') mulExpression]

newAnonClassExpression ::= 'new' arguments? 'class' arguments? baseClassList? structBody

newExpression ::= 'new' type ( ( '[' assignExpression ']' ) | arguments )? | newAnonClassExpression

nonVoidInitializer ::= assignExpression | arrayInitializer | structInitializer



 orExpression ::= xorExpression ['|' orExpression]

 orOrExpression ::= andAndExpression ['||' orOrExpression]

outStatement ::= 'out' ( '(' Identifier ')' )? blockStatement

parameter ::=
     parameterAttribute* type (Identifier? '...' | (Identifier? ('=' assignExpression)?))?

parameterAttribute ::= typeConstructor | 'final' | 'in' | 'lazy' | 'out' | 'ref' | 'scope' | 'auto' | 'return'

parameters ::= '(' parameter ( ',' parameter )* ( ',' '...' )? ')' | '(' '...' ')' | '(' ')'

  powExpression ::= unaryExpression ['^^' powExpression]

pragmaDeclaration ::= pragmaExpression ';'

pragmaExpression ::= '(' Identifier ( ',' argumentList )? ')'

 primaryExpression ::=
       identifierOrTemplateInstance
     | '.' identifierOrTemplateInstance
     | builtinType '.' Identifier
     | typeofExpression
     | typeidExpression
     | vector
     | arrayLiteral
     | assocArrayLiteral
     | '(' expression ')'
     | isExpression
     | lambdaExpression
     | functionLiteralExpression
     | traitsExpression
     | mixinExpression
     | importExpression
     | '$'
     | 'this'
     | 'super'
     | 'null'
     | 'true'
     | 'false'
     | '__DATE__'
     | '__TIME__'
     | '__TIMESTAMP__'
     | '__VENDOR__'
     | '__VERSION__'
     | '__FILE__'
     | '__LINE__'
     | '__MODULE__'
     | '__FUNCTION__'
     | '__PRETTY_FUNCTION__'
     | INTEGER_LITERAL
     | FLOAT_LITERAL
     | StringLiteral+
     | CHARACTER_LITERAL

register ::= Identifier | Identifier '(' INTEGER_LITERAL ')'

relExpression ::= shiftExpression [relOperator relExpression]

relOperator ::=
       '<'
     | '<='
     | '>'
     | '>='
     | '!<>='
     | '!<>'
     | '<>'
     | '<>='
     | '!>'
     | '!>='
     | '!<'
     | '!<='


returnStatement ::= 'return' expression? ';'

scopeGuardStatement ::= 'scope' '(' Identifier ')' statementNoCaseNoDefault

sharedStaticConstructor ::= 'shared' 'static' 'this' '(' ')' functionBody

sharedStaticDestructor ::= 'shared' 'static' '~' 'this' '(' ')' functionBody

shiftExpression ::= addExpression [('<<' | '>>' | '>>>') shiftExpression]




statement ::= statementNoCaseNoDefault | caseStatement | caseRangeStatement | defaultStatement

statementNoCaseNoDefault ::= labeledStatement
| blockStatement
| ifStatement
| whileStatement
| doStatement
| forStatement
| foreachStatement
| switchStatement
| finalSwitchStatement
| continueStatement
| breakStatement
| returnStatement
| gotoStatement
| withStatement
| synchronizedStatement
| tryStatement
| throwStatement
| scopeGuardStatement
| asmStatement
| conditionalStatement
| staticAssertStatement
| versionSpecification
| debugSpecification
| expressionStatement
| functionCallStatement




functionCallStatement ::=
     functionCallExpression ';'


staticAssertDeclaration ::= staticAssertStatement

staticAssertStatement ::= 'static' assertExpression ';'

staticConstructor ::= 'static' 'this' '(' ')' functionBody

staticDestructor ::= 'static' '~' 'this' '(' ')' functionBody

staticIfCondition ::= 'static' 'if' '(' assignExpression ')'
//
storageClass ::= alignAttribute | linkageAttribute | atAttribute | typeConstructor | deprecated | 'abstract' | 'auto' | 'enum' | 'extern' | 'final' | 'nothrow' | 'override' | 'pure' | 'ref' | '__gshared' | 'scope' | 'static' | 'synchronized'

structBody ::= '{' declaration* '}'

structDeclaration ::= 'struct' Identifier? ( templateParameters constraint? structBody | ( structBody | ';' ) )

structInitializer ::= '{' structMemberInitializers? '}'

structMemberInitializer ::= ( Identifier ':' )? nonVoidInitializer

structMemberInitializers ::= structMemberInitializer ( ',' structMemberInitializer? )*

switchStatement ::= 'switch' '(' expression ')' statement

symbol ::= '.'? identifierOrTemplateChain

synchronizedStatement ::= 'synchronized' ( '(' expression ')' )? statementNoCaseNoDefault

templateAliasParameter ::= 'alias' type? Identifier ( ':' ( type | assignExpression ) )? ( '=' ( type | assignExpression ) )?

templateArgument ::= type | assignExpression

templateArgumentList ::= templateArgument ( ',' templateArgument? )*

templateArguments ::= '!' ( '(' templateArgumentList? ')' ) | templateSingleArgument

templateDeclaration ::= 'template' Identifier templateParameters constraint? '{' declaration* '}'

templateInstance ::= Identifier templateArguments

templateMixinExpression ::= 'mixin' mixinTemplateName templateArguments? Identifier?

templateParameter ::= templateTypeParameter | templateValueParameter | templateAliasParameter | templateTupleParameter | templateThisParameter

templateParameterList ::= templateParameter ( ',' templateParameter? )*

templateParameters ::= '(' templateParameterList? ')'

templateSingleArgument ::= builtinType | Identifier | CHARACTER_LITERAL | StringLiteral | INTEGER_LITERAL | FLOAT_LITERAL | 'true' | 'false' | 'null' | 'this' | '__DATE__' | '__TIME__' | '__TIMESTAMP__' | '__VENDOR__' | '__VERSION__' | '__FILE__' | '__LINE__' | '__MODULE__' | '__FUNCTION__' | '__PRETTY_FUNCTION__'

templateThisParameter ::= 'this' templateTypeParameter

templateTupleParameter ::= Identifier '...'

templateTypeParameter ::= Identifier ( ':' type )? ( '=' type )?

templateValueParameter ::= type Identifier ( ':' assignExpression )? templateValueParameterDefault?

templateValueParameterDefault ::= '=' ( '__FILE__' | '__MODULE__' | '__LINE__' | '__FUNCTION__' | '__PRETTY_FUNCTION__' | assignExpression )

ternaryExpression ::= orOrExpression ('?' expression ':' ternaryExpression)?

throwStatement ::= 'throw' expression ';'

traitsExpression ::= '__traits' '(' Identifier ',' templateArgumentList ')'

tryStatement ::= 'try' declarationOrStatement ( catches | catches finally_ | finally_ )

type ::= typeConstructors? type2 typeSuffix*

type2 ::= builtinType | symbol | typeofExpression ( '.' identifierOrTemplateChain )? | typeConstructor '(' type ')' | vector

typeConstructor ::= 'const' | 'immutable' | 'inout' | 'shared'

typeConstructors ::= typeConstructor

typeSpecialization ::= type | 'struct' | 'union' | 'class' | 'interface' | 'enum' | 'function' | 'delegate' | 'super' | 'const' | 'immutable' | 'inout' | 'shared' | 'return' | 'typedef' | '__parameters'

typeSuffix ::= '*' | '[' type? ']' | '[' assignExpression ']' | '[' assignExpression '..' assignExpression ']' | ( 'delegate' | 'function' ) parameters memberFunctionAttribute*

typeidExpression ::= 'typeid' '(' ( type | expression ) ')'

typeofExpression ::= 'typeof' '(' ( expression | 'return' ) ')'



unionDeclaration ::= 'union' Identifier templateParameters constraint? structBody | 'union' Identifier ( structBody | ';' ) | 'union' structBody

unittest ::= 'unittest' blockStatement

variableDeclaration ::=
   storageClass* type declarator ( ',' declarator )* ';'
   | storageClass* type Identifier '=' functionBody ';'
   | autoDeclaration


vector ::= '__vector' '(' type ')'

versionCondition ::= 'version' '(' ( INTEGER_LITERAL | Identifier | 'unittest' | 'assert' ) ')'

versionSpecification ::= 'version' '=' ( Identifier | INTEGER_LITERAL ) ';'

whileStatement ::= 'while' '(' expression ')' declarationOrStatement

withStatement ::= 'with' '(' expression ')' statementNoCaseNoDefault

xorExpression ::= andExpression ['^' xorExpression]

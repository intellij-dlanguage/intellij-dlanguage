{

  parserClass="net.masterthought.dlanguage.parser.DLanguageParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="DLanguage"
  psiImplClassSuffix="Impl"
  psiPackage="net.masterthought.dlanguage.psi"
  psiImplPackage="net.masterthought.dlanguage.psi.impl"

  elementTypeHolderClass="net.masterthought.dlanguage.psi.DLanguageTypes"
  elementTypeClass="net.masterthought.dlanguage.psi.DLanguageElementType"
  tokenTypeClass="net.masterthought.dlanguage.psi.DLanguageTokenType"

  generateTokenAccessors=true

tokens = [
 KW_MODULE = "module"
 KW_IMPORT = "import"
 KW_STATIC = "static"
 KW_BOOL = "bool"
 KW_BYTE = "byte"
 KW_UBYTE = "ubyte"
 KW_SHORT = "short"
 KW_USHORT = "ushort"
 KW_INT = "int"
 KW_UINT = "uint"
 KW_LONG = "long"
 KW_ULONG = "ulong"
 KW_CHAR = "char"
 KW_WCHAR = "wchar"
 KW_DCHAR = "dchar"
 KW_FLOAT = "float"
 KW_DOUBLE = "double"
 KW_REAL = "real"
 KW_IFLOAT = "ifloat"
 KW_IDOUBLE = "idouble"
 KW_IREAL = "ireal"
 KW_CFLOAT = "cfloat"
 KW_CDOUBLE = "cdouble"
 KW_CREAL = "creal"
 KW_VOID = "void"
 KW_TYPEOF = "typeof"
 KW_CONST = "const"
 KW_IMMUTABLE = "immutable"
 KW_SHARED = "shared"
 KW_INOUT = "inout"
 KW_DELEGATE = "delegate"
 KW_FUNCTION = "function"
 KW_NOTHROW = "nothrow"
 KW_PURE = "pure"
 KW_THIS = "this"
 KW___FILE__ = "__FILE__"
 KW___MODULE__ = "__MODULE__"
 KW___LINE__ = "__LINE__"
 KW___FUNCTION__ = "__FUNCTION__"
 KW___PRETTY_FUNCTION__ = "__PRETTY_FUNCTION__"
 KW_ABSTRACT = "abstract"
 KW_ALIAS = "alias"
 KW_AUTO = "auto"
 KW_DEPRECATED = "deprecated"
 KW_ENUM = "enum"
 KW_EXTERN = "extern"
 KW_FINAL = "final"
 KW_OVERRIDE = "override"
 KW___GSHARED = "__gshared"
 KW_SCOPE = "scope"
 KW_SYNCHRONIZED = "synchronized"
 KW_RETURN = "return"
 KW_SUPER = "super"
 KW_ALIGN = "align"
 KW_PRAGMA = "pragma"
 KW_PACKAGE = "package"
 KW_PRIVATE = "private"
 KW_PROTECTED = "protected"
 KW_PUBLIC = "public"
 KW_EXPORT = "export"
 KW_PROPERTY = "property"
 KW_SAFE = "safe"
 KW_TRUSTED = "trusted"
 KW_SYSTEM = "system"
 KW_DISABLE = "disable"
 KW_DELETE = "delete"
 KW_NULL = "null"
 KW_TRUE = "true"
 KW_FALSE = "false"
 KW_NEW = "new"
 KW_TYPEID = "typeid"
 KW_IS = "is"
 KW_STRUCT = "struct"
 KW_UNION = "union"
 KW_CLASS = "class"
 KW_INTERFACE = "interface"
 KW___PARAMETERS = "__parameters"
 KW_IN = "in"
 KW_ASM = "asm"
 KW_ASSERT = "assert"
 KW_CASE = "case"
 KW_CAST = "cast"
 KW_REF = "ref"
 KW_BREAK = "break"
 KW_CONTINUE = "continue"
 KW_DO = "do"
 KW_ELSE = "else"
 KW_FOR = "for"
 KW_FOREACH = "foreach"
 KW_FOREACH_REVERSE = "foreach_reverse"
 KW_GOTO = "goto"
 KW_IF = "if"
 KW_CATCH = "catch"
 KW_FINALLY = "finally"
 KW_SWITCH = "switch"
 KW_THROW = "throw"
 KW_TRY = "try"
 KW_DEFAULT = "default"
 KW_WHILE = "while"
 KW_WITH = "with"
 KW_VERSION = "version"
 KW_DEBUG = "debug"
 KW_MIXIN = "mixin"
 KW_INVARIANT = "invariant"
 KW_BODY = "body"
 KW_TEMPLATE = "template"
 KW_LAZY = "lazy"
 KW_OUT = "out"
 KW_NOGC = "nogc"
 KW___TRAITS = "__traits"
 KW_UNITTEST = "unittest"
 OP_SCOLON = ";"
 OP_COLON = ":"
 OP_EQ = "="
 OP_COMMA = ","
 OP_PAR_LEFT = "("
 OP_PAR_RIGHT = ")"
 OP_BRACKET_LEFT = "["
 OP_BRACKET_RIGHT = "]"
 OP_BRACES_LEFT = "{"
 OP_BRACES_RIGHT = "}"
 OP_ASTERISK = "*"
 OP_DDOT = ".."
 OP_TRIPLEDOT = "..."
 OP_AT = "@"
 OP_PLUS_EQ = "+="
 OP_MINUS_EQ = "-="
 OP_MUL_EQ = "*="
 OP_DIV_EQ = "/="
 OP_MOD_EQ = "%="
 OP_AND_EQ = "&="
 OP_OR_EQ = "|="
 OP_XOR_EQ = "^="
 OP_TILDA_EQ = "~="
 OP_SH_LEFT_EQ = "<<="
 OP_SH_RIGHT_EQ = ">>="
 OP_USH_RIGHT_EQ = ">>>="
 OP_POW_EQ = "^^="
 OP_QUEST = "?"
 OP_BOOL_OR = "||"
 OP_BOOL_AND = "&&"
 OP_OR = "|"
 OP_XOR = "^"
 OP_SH_LEFT = "<<"
 OP_SH_RIGHT = ">>"
 OP_USH_RIGHT = ">>>"
 OP_PLUS = "+"
 OP_MINUS = "-"
 OP_TILDA = "~"
 OP_DIV = "/"
 OP_MOD = "%"
 OP_AND = "&"
 OP_PLUS_PLUS = "++"
 OP_MINUS_MINUS = "--"
 OP_NOT = "!"
 OP_POW = "^^"
 OP_DOLLAR = "$"
 OP_EQ_EQ = "=="
 OP_NOT_EQ = "!="
 OP_LESS = "<"
 OP_LESS_EQ = "<="
 OP_GT = ">"
 OP_GT_EQ = ">="
 OP_UNORD = "!<>="
 OP_UNORD_EQ = "!<>"
 OP_LESS_GR = "<>"
 OP_LESS_GR_EQ = "<>="
 OP_NOT_GR = "!>"
 OP_NOT_GR_EQ = "!>="
 OP_NOT_LESS = "!<"
 OP_NOT_LESS_EQ = "!<="
 OP_LAMBDA_ARROW = "=>"
 OP_DOT = "."

 ID = "regexp:\w+"
 space='regexp:\s+'
 line_comment="regexp://.*"
 block_comment="regexp:/\*(.|\n)*\*/"

  DOUBLE_QUOTED_STRING = 'regexp:\"([^\\"]|((\\"|\\\?|\\\|\\0|\\a|\\b|\\f|\\n|\\r|\\t|\\v)|(\\x[0-9abcdefABCDEF_]{2})|(\\[0-7])|(\\[0-7]{2})|(\\[0-7]{3})|(\\u[0-9abcdefABCDEF_]{4})|(\\U[0-9abcdefABCDEF_]{8})|(\\&([a-zA-Z_])([a-zA-Z0-9_])*;)))*\"[cwd]*'

 ]

}

dFile ::= item_*

private item_ ::= (moduleDeclaration | declarationOrStatement)

Identifier ::= ID
StringLiteral  ::= (WYSIWYG_STRING|ALTERNATE_WYSIWYG_STRING|DOUBLE_QUOTED_STRING|HEX_STRING|DELIMITED_STRING)

 addExpression ::= 
       mulExpression
     | addExpression ('+' | '-' | '~') mulExpression
     
 aliasDeclaration ::= 
       'alias' aliasInitializer (',' aliasInitializer)* ';'
     | 'alias' storageClass* type identifierList ';'
     
 aliasInitializer ::=
     Identifier templateParameters? '=' storageClass* type
     
 aliasThisDeclaration ::=
     'alias' Identifier 'this' ';'
     
 alignAttribute ::= 
     'align' ('(' INTEGER_LITERAL ')')?
     
 andAndExpression ::= 
       orExpression
     | andAndExpression '&&' orExpression
     
 andExpression ::= 
       cmpExpression
     | andExpression '&' cmpExpression
     
 argumentList ::= 
     assignExpression (',' assignExpression?)*
     
 arguments ::= 
     '(' argumentList? ')'
     
 arrayInitializer ::= 
       '[' ']'
     | '[' arrayMemberInitialization (',' arrayMemberInitialization?)* ']'
     
 arrayLiteral ::= 
     '[' argumentList? ']'
     
 arrayMemberInitialization ::= 
     (assignExpression ':')? nonVoidInitializer
     
 asmAddExp ::= 
       asmMulExp
     | asmAddExp ('+' | '-') asmMulExp
     
 asmAndExp ::= 
       asmEqualExp
     | asmAndExp '&' asmEqualExp
     
 asmBrExp ::= 
       asmUnaExp
     | asmBrExp? '[' asmExp ']'
     
 asmEqualExp ::= 
       asmRelExp
     | asmEqualExp ('==' | '!=') asmRelExp
     
 asmExp ::= 
     asmLogOrExp ('?' asmExp ':' asmExp)?
     
 asmInstruction ::= 
       Identifier
     | 'align' INTEGER_LITERAL
     | 'align' Identifier
     | Identifier ':' asmInstruction
     | Identifier operands
     | 'in' operands
     | 'out' operands
     | 'int' operands
     
 asmLogAndExp ::= 
     asmOrExp
     asmLogAndExp '&&' asmOrExp
     
 asmLogOrExp ::= 
       asmLogAndExp
     | asmLogOrExp '||' asmLogAndExp
     
 asmMulExp ::= 
       asmBrExp
     | asmMulExp ('*' | '/' | '%') asmBrExp
     
 asmOrExp ::= 
       asmXorExp
     | asmOrExp '|' asmXorExp
     
 asmPrimaryExp ::= 
       INTEGER_LITERAL
     | FLOAT_LITERAL
     | StringLiteral
     | register
     | identifierChain
     | '$'
     
 asmRelExp ::= 
       asmShiftExp
     | asmRelExp (('<' | '<=' | '>' | '>=') asmShiftExp)?
     
 asmShiftExp ::= 
     asmAddExp
     asmShiftExp ('<<' | '>>' | '>>>') asmAddExp
     
 asmStatement ::= 
     'asm' functionAttributes? '{' asmInstruction+ '}'
     
 asmTypePrefix ::= 
       Identifier Identifier?
     | 'byte' Identifier?
     | 'short' Identifier?
     | 'int' Identifier?
     | 'float' Identifier?
     | 'double' Identifier?
     | 'real' Identifier?
     
 asmUnaExp ::= 
       asmTypePrefix asmExp
     | Identifier asmExp
     | '+' asmUnaExp
     | '-' asmUnaExp
     | '!' asmUnaExp
     | '~' asmUnaExp
     | asmPrimaryExp
     
 asmXorExp ::= 
       asmAndExp
     | asmXorExp '^' asmAndExp
     
 assertExpression ::= 
     'assert' '(' assignExpression (',' assignExpression)? ')'
     
 assignExpression ::= 
     ternaryExpression (assignOperator expression)?
     
 assignOperator ::= 
       '='
     | '>>>='
     | '>>='
     | '<<='
     | '+='
     | '-='
     | '*='
     | '%='
     | '&='
     | '/='
     | '|='
     | '^^='
     | '^='
     | '~='
     
 assocArrayLiteral ::= 
     '[' keyValuePairs ']'
     
 atAttribute ::= 
       '@' Identifier
     | '@' Identifier '(' argumentList? ')'
     | '@' '(' argumentList ')'
     
 attribute ::= 
      pragmaExpression
     | alignAttribute
     | deprecated
     | atAttribute
     | linkageAttribute
     | 'export'
     | 'package'
     | 'private'
     | 'protected'
     | 'public'
     | 'static'
     | 'extern'
     | 'abstract'
     | 'final'
     | 'override'
     | 'synchronized'
     | 'auto'
     | 'scope'
     | 'const'
     | 'immutable'
     | 'inout'
     | 'shared'
     | '_gshared'
     | 'nothrow'
     | 'pure'
     | 'ref'
     
 attributeDeclaration ::= 
     attribute ':'
     
 autoDeclaration ::=
     storageClass Identifier '=' initializer (',' Identifier '=' initializer)* ';'
     
 blockStatement ::= 
     '{' declarationsAndStatements? '}'
     
 bodyStatement ::= 
     'body' blockStatement
     
 breakStatement ::= 
     'break' Identifier? ';'
     
 baseClass ::= 
     type2
     
 baseClassList ::= 
     baseClass (',' baseClass)*
     
 builtinType ::= 
      'bool'
    | 'byte'
    | 'ubyte'
    | 'short'
    | 'ushort'
    | 'int'
    | 'uint'
    | 'long'
    | 'ulong'
    | 'char'
    | 'wchar'
    | 'dchar'
    | 'float'
    | 'double'
    | 'real'
    | 'ifloat'
    | 'idouble'
    | 'ireal'
    | 'cfloat'
    | 'cdouble'
    | 'creal'
    | 'void'
    
 caseRangeStatement ::= 
     'case' assignExpression ':' '...' 'case' assignExpression ':' declarationsAndStatements
     
 caseStatement ::= 
     'case' argumentList ':' declarationsAndStatements
     
 castExpression ::= 
     'cast' '(' (type | castQualifier)? ')' unaryExpression
     
 castQualifier ::= 
      'const'
    | 'const' 'shared'
    | 'immutable'
    | 'inout'
    | 'inout' 'shared'
    | 'shared'
    | 'shared' 'const'
    | 'shared' 'inout'
    
 catch ::= 
     'catch' '(' type Identifier? ')' declarationOrStatement
     
 catches ::= 
       catch
     | catch* lastCatch
     
 classDeclaration ::= 
       'class' Identifier ';'
     | 'class' Identifier (':' baseClassList)? structBody
     | 'class' Identifier templateParameters constraint? (structBody | ';')
     | 'class' Identifier templateParameters constraint? (':' baseClassList)? structBody
     | 'class' Identifier templateParameters (':' baseClassList)? constraint? structBody
     
 cmpExpression ::= 
       shiftExpression
     | equalExpression
     | identityExpression
     | relExpression
     | inExpression
     
 compileCondition ::= 
       versionCondition
     | debugCondition
     | staticIfCondition
     
 conditionalDeclaration ::= 
       compileCondition declaration
     | compileCondition ':' declaration
     | compileCondition declaration 'else' declaration
     
 conditionalStatement ::= 
     compileCondition declarationOrStatement ('else' declarationOrStatement)?
     
 constraint ::= 
     'if' '(' expression ')'
     
 constructor ::= 
       'this' templateParameters? parameters memberFunctionAttribute* constraint? (functionBody | ';')
     
 continueStatement ::= 
     'continue' Identifier? ';'
     
 debugCondition ::= 
     'debug' ('(' (INTEGER_LITERAL | Identifier) ')')?
     
 debugSpecification ::= 
     'debug' '=' (Identifier | INTEGER_LITERAL) ';'
     
 declaration ::= 
     attribute* declaration2
     
  declaration2 ::= 
       aliasDeclaration
     | aliasThisDeclaration
     | anonymousEnumDeclaration
     | attributeDeclaration
     | classDeclaration
     | conditionalDeclaration
     | constructor
     | debugSpecification
     | destructor
     | enumDeclaration
     | eponymousTemplateDeclaration
     | functionDeclaration
     | importDeclaration
     | interfaceDeclaration
     | invariant
     | mixinDeclaration
     | mixinTemplateDeclaration
     | pragmaDeclaration
     | sharedStaticConstructor
     | sharedStaticDestructor
     | staticAssertDeclaration
     | staticConstructor
     | staticDestructor
     | structDeclaration
     | templateDeclaration
     | unionDeclaration
     | unittest
     | variableDeclaration
     | versionSpecification
     | '{' declaration '}'
     
 declarationsAndStatements ::= 
     declarationOrStatement
     
 declarationOrStatement ::= 
       declaration
     | statement
     
 declarator ::= 
       Identifier
     | Identifier '=' initializer
     | Identifier templateParameters '=' initializer
     
 defaultStatement ::= 
     'default' ':' declarationsAndStatements
     
 deleteExpression ::= 
     'delete' unaryExpression
     
 deprecated ::= 
     'deprecated' ('(' StringLiteral ')')?
     
 destructor ::= 
     '~' 'this' '(' ')' memberFunctionAttribute* (functionBody | ';')
     
 doStatement ::= 
     'do' statementNoCaseNoDefault 'while' '(' expression ')' ';'
     
 enumBody ::= 
     '{' enumMember (',' enumMember?)* '}'
     
 anonymousEnumMember ::= 
       type Identifier '=' assignExpression
     | Identifier '=' assignExpression
     | Identifier
     
 anonymousEnumDeclaration ::= 
     'enum' (':' type)? '{' anonymousEnumMember '}'
     
 enumDeclaration ::= 
       'enum' Identifier (':' type)? ';'
     | 'enum' Identifier (':' type)? enumBody
     
 enumMember ::= 
       Identifier
     | Identifier '=' assignExpression
     
 eponymousTemplateDeclaration ::= 
     'enum' Identifier templateParameters '=' assignExpression ';'
     
 equalExpression ::= 
     shiftExpression ('==' | '!=') shiftExpression
     
 expression ::= 
     assignExpression (',' assignExpression)*
     
 expressionStatement ::= 
     expression ';'
     
 finalSwitchStatement ::= 
     'final' switchStatement
     
 finally ::= 
     'finally' declarationOrStatement
     
 forStatement ::= 
     'for' '(' (declaration | statementNoCaseNoDefault) expression? ';' expression? ')' declarationOrStatement
     
 foreachStatement ::= 
       ('foreach' | 'foreach_reverse') '(' foreachTypeList ';' expression ')' declarationOrStatement
     | ('foreach' | 'foreach_reverse') '(' foreachType ';' expression '..' expression ')' declarationOrStatement
     
 foreachType ::= 
       'ref'? typeConstructors? type? Identifier
     | typeConstructors? 'ref'? type? Identifier
     
 foreachTypeList ::= 
     foreachType (',' foreachType)*
     
 functionAttribute ::= 
       atAttribute
     | 'pure'
     | 'nothrow'
     
 functionBody ::= 
       blockStatement
     | (inStatement | outStatement | outStatement inStatement | inStatement outStatement)? bodyStatement
     
 functionCallExpression ::= 
      symbol arguments
      unaryExpression arguments
     | type arguments
     
 functionDeclaration ::= 
       (storageClass+ | type) Identifier parameters memberFunctionAttribute* (functionBody | ';')
     | (storageClass+ | type) Identifier templateParameters parameters memberFunctionAttribute* constraint? (functionBody | ';')
     
 functionLiteralExpression ::= 
     (('function' | 'delegate') type?)? (parameters functionAttribute*)? functionBody
     
 gotoStatement ::= 
     'goto' (Identifier | 'default' | 'case' expression?) ';'
     
 identifierChain ::= 
     Identifier ('.' Identifier)*
     
 identifierList ::= 
     Identifier (',' Identifier)*
     
 identifierOrTemplateChain ::= 
     identifierOrTemplateInstance ('.' identifierOrTemplateInstance)*
     
 identifierOrTemplateInstance ::= 
       Identifier
     | templateInstance
     
 identityExpression ::= 
     shiftExpression ('is' | ('!' 'is')) shiftExpression
     
 ifStatement ::= 
     'if' '(' ifCondition ')' declarationOrStatement ('else' declarationOrStatement)?
  ifCondition ::= 
       'auto' Identifier '=' expression
     | type Identifier '=' expression
     | expression
     
 importBind ::= 
     Identifier ('=' Identifier)?
     
 importBindings ::= 
     singleImport ':' importBind (',' importBind)*
     
 importDeclaration ::= 
       'import' singleImport (',' singleImport)* (',' importBindings)? ';'
     | 'import' importBindings ';'
     
 importExpression ::= 
     'import' '(' assignExpression ')'
     
 indexExpression ::= 
     unaryExpression '[' argumentList ']'
     
 inExpression ::= 
     shiftExpression ('in' | ('!' 'in')) shiftExpression
     
 inStatement ::= 
     'in' blockStatement
     
 initializer ::= 
       'void'
     | nonVoidInitializer
     
 interfaceDeclaration ::= 
       'interface' Identifier ';'
     | 'interface' Identifier (':' baseClassList)? structBody
     | 'interface' Identifier templateParameters constraint? (':' baseClassList)? structBody
     | 'interface' Identifier templateParameters (':' baseClassList)? constraint? structBody
     
 invariant ::= 
     'invariant' ('(' ')')? blockStatement
     
 isExpression ::= 
     'is' '(' type Identifier? ')'
     'is' '(' type Identifier? ':' typeSpecialization ')'
     'is' '(' type Identifier? '=' typeSpecialization ')'
     'is' '(' type Identifier? ':' typeSpecialization ',' templateParameterList ')'
     'is' '(' type Identifier? '=' typeSpecialization ',' templateParameterList ')'
     
 keyValuePair ::= 
     assignExpression ':' assignExpression
     
 keyValuePairs ::= 
     keyValuePair (',' keyValuePair)* ','?
     
 labeledStatement ::= 
     Identifier ':' declarationOrStatement?
     
 lambdaExpression ::= 
       Identifier '=>' assignExpression
     | 'function' type? parameters functionAttribute* '=>' assignExpression
     | 'delegate' type? parameters functionAttribute* '=>' assignExpression
     | parameters functionAttribute* '=>' assignExpression
     
 lastCatch ::= 
     'catch' statementNoCaseNoDefault
     
 linkageAttribute ::= 
     'extern' '(' Identifier ('++' (',' identifierChain)?)? ')'
     
 memberFunctionAttribute ::= 
       functionAttribute
     | 'immutable'
     | 'inout'
     | 'shared'
     | 'const'
     | 'return'
     
 mixinDeclaration ::= 
       mixinExpression ';'
     | templateMixinExpression ';'
     
 mixinExpression ::= 
     'mixin' '(' assignExpression ')'
     
 mixinTemplateDeclaration ::= 
     'mixin' templateDeclaration
     
 mixinTemplateName ::= 
       symbol
     | typeofExpression '.' identifierOrTemplateChain

 moduleDeclaration ::= 
     deprecated? 'module' identifierChain ';'
     
 mulExpression ::= 
       powExpression
     | mulExpression ('*' | '/' | '%') powExpression
     
 newAnonClassExpression ::= 
     'new' arguments? 'class' arguments? baseClassList? structBody
     
 newExpression ::= 
       'new' type (('[' assignExpression ']') | arguments)?
     | newAnonClassExpression
     
 nonVoidInitializer ::= 
       assignExpression
     | arrayInitializer
     | structInitializer
     
 operands ::= 
       asmExp
     | asmExp ',' operands
     
 orExpression ::= 
       xorExpression
     | orExpression '|' xorExpression
     
 orOrExpression ::= 
       andAndExpression
     | orOrExpression '||' andAndExpression
     
 outStatement ::= 
     'out' ('(' Identifier ')')? blockStatement
     
 parameter ::= 
     parameterAttribute* type
     parameterAttribute* type Identifier? '...'
     parameterAttribute* type Identifier? ('=' assignExpression)?
     
 parameterAttribute ::= 
       typeConstructor
     | 'final'
     | 'in'
     | 'lazy'
     | 'out'
     | 'ref'
     | 'scope'
     | 'auto'
     | 'return'
     
 parameters ::= 
       '(' parameter (',' parameter)* (',' '...')? ')'
     | '(' '...' ')'
     | '(' ')'
     
 postblit ::= 
     'this' '(' 'this' ')' memberFunctionAttribute* (functionBody | ';')
     
 powExpression ::= 
       unaryExpression
     | powExpression '^^' unaryExpression
     
 pragmaDeclaration ::= 
     pragmaExpression ';'
     
 pragmaExpression ::= 
     'pragma' '(' Identifier (',' argumentList)? ')'
     
 primaryExpression ::= 
       identifierOrTemplateInstance
     | '.' identifierOrTemplateInstance
     | typeConstructor '(' builtinType ')' '.' Identifier
     | builtinType '.' Identifier
     | builtinType arguments
     | typeofExpression
     | typeidExpression
     | vector
     | arrayLiteral
     | assocArrayLiteral
     | '(' expression ')'
     | isExpression
     | lambdaExpression
     | functionLiteralExpression
     | traitsExpression
     | mixinExpression
     | importExpression
     | '$'
     | 'this'
     | 'super'
     | 'null'
     | 'true'
     | 'false'
     | '__DATE__'
     | '__TIME__'
     | '__TIMESTAMP__'
     | '__VENDOR__'
     | '__VERSION__'
     | '__FILE__'
     | '__LINE__'
     | '__MODULE__'
     | '__FUNCTION__'
     | '__PRETTY_FUNCTION__'
     | INTEGER_LITERAL
     | FLOAT_LITERAL
     | StringLiteral+
     | CharacterLiteral
     
 register ::= 
       Identifier
     | Identifier '(' INTEGER_LITERAL ')'
     
 relExpression ::= 
       shiftExpression
     | relExpression relOperator shiftExpression
     
 relOperator ::= 
       '<'
     | '<='
     | '>'
     | '>='
     | '!<>='
     | '!<>'
     | '<>'
     | '<>='
     | '!>'
     | '!>='
     | '!<'
     | '!<='
     
 returnStatement ::= 
     'return' expression? ';'
     
 scopeGuardStatement ::= 
     'scope' '(' Identifier ')' statementNoCaseNoDefault
     
 sharedStaticConstructor ::= 
     'shared' 'static' 'this' '(' ')' functionBody
     
 sharedStaticDestructor ::= 
     'shared' 'static' '~' 'this' '(' ')' functionBody
     
 shiftExpression ::= 
       addExpression
     | shiftExpression ('<<' | '>>' | '>>>') addExpression
     
 singleImport ::= 
     (Identifier '=')? identifierChain
     
 sliceExpression ::= 
       unaryExpression '[' assignExpression '..' assignExpression ']'
     | unaryExpression '[' ']'
     
 statement ::= 
       statementNoCaseNoDefault
     | caseStatement
     | caseRangeStatement
     | defaultStatement
     
 statementNoCaseNoDefault ::= 
       labeledStatement
     | blockStatement
     | ifStatement
     | whileStatement
     | doStatement
     | forStatement
     | foreachStatement
     | switchStatement
     | finalSwitchStatement
     | continueStatement
     | breakStatement
     | returnStatement
     | gotoStatement
     | withStatement
     | synchronizedStatement
     | tryStatement
     | throwStatement
     | scopeGuardStatement
     | asmStatement
     | conditionalStatement
     | staticAssertStatement
     | versionSpecification
     | debugSpecification
     | expressionStatement
     
 staticAssertDeclaration ::= 
     staticAssertStatement
     
 staticAssertStatement ::= 
     'static' assertExpression ';'
     
 staticConstructor ::= 
     'static' 'this' '(' ')' functionBody
     
 staticDestructor ::= 
     'static' '~' 'this' '(' ')' functionBody
     
 staticIfCondition ::= 
     'static' 'if' '(' assignExpression ')'
     
 storageClass ::= 
       alignAttribute
     | linkageAttribute
     | atAttribute
     | typeConstructor
     | deprecated
     | 'abstract'
     | 'auto'
     | 'enum'
     | 'extern'
     | 'final'
     | 'nothrow'
     | 'override'
     | 'pure'
     | 'ref'
     | '__gshared'
     | 'scope'
     | 'static'
     | 'synchronized'
     
 structBody ::= 
     '{' declaration* '}'
     
 structDeclaration ::= 
     'struct' Identifier? (templateParameters constraint? structBody | (structBody | ';'))
     
 structInitializer ::= 
     '{' structMemberInitializers? '}'
     
 structMemberInitializer ::= 
     (Identifier ':')? nonVoidInitializer
     
 structMemberInitializers ::= 
     structMemberInitializer (',' structMemberInitializer?)*
     
 switchStatement ::= 
     'switch' '(' expression ')' statement
     
 symbol ::= 
     '.'? identifierOrTemplateChain
     
 synchronizedStatement ::= 
     'synchronized' ('(' expression ')')? statementNoCaseNoDefault
     
 templateAliasParameter ::= 
     'alias' type? Identifier (':' (type | assignExpression))? ('=' (type | assignExpression))?
     
 templateArgument ::= 
       type
     | assignExpression
     
 templateArgumentList ::= 
     templateArgument (',' templateArgument?)*
     
 templateArguments ::= 
     '!' ('(' templateArgumentList? ')') | templateSingleArgument
     
 templateDeclaration ::= 
       'template' Identifier templateParameters constraint? '{' declaration* '}'
     
 templateInstance ::= 
     Identifier templateArguments
     
 templateMixinExpression ::= 
     'mixin' mixinTemplateName templateArguments? Identifier?
     
 templateParameter ::= 
       templateTypeParameter
     | templateValueParameter
     | templateAliasParameter
     | templateTupleParameter
     | templateThisParameter
     
 templateParameterList ::= 
     templateParameter (',' templateParameter?)*
     
 templateParameters ::= 
     '(' templateParameterList? ')'
     
 templateSingleArgument ::= 
       builtinType
     | Identifier
     | CharacterLiteral
     | StringLiteral
     | INTEGER_LITERAL
     | FLOAT_LITERAL
     | 'true'
     | 'false'
     | 'null'
     | 'this'
     | '__DATE__'
     | '__TIME__'
     | '__TIMESTAMP__'
     | '__VENDOR__'
     | '__VERSION__'
     | '__FILE__'
     | '__LINE__'
     | '__MODULE__'
     | '__FUNCTION__'
     | '__PRETTY_FUNCTION__'
     
 templateThisParameter ::= 
     'this' templateTypeParameter
     
 templateTupleParameter ::= 
     Identifier '...'
     
 templateTypeParameter ::= 
     Identifier (':' type)? ('=' type)?
     
 templateValueParameter ::= 
     type Identifier (':' assignExpression)? templateValueParameterDefault?
     
 templateValueParameterDefault ::= 
     '=' ('__FILE__' | '__MODULE__' | '__LINE__' | '__FUNCTION__' | '__PRETTY_FUNCTION__' | assignExpression)
     
 ternaryExpression ::= 
     orOrExpression ('?' expression ':' ternaryExpression)?
     
 throwStatement ::= 
     'throw' expression ';'
     
 traitsExpression ::= 
     '__traits' '(' Identifier ',' TemplateArgumentList ')'
     
 tryStatement ::= 
     'try' declarationOrStatement (catches | catches finally | finally)
     
 type ::= 
     typeConstructors? type2 typeSuffix*
     
 type2 ::= 
       builtinType
     | symbol
     | typeofExpression ('.' identifierOrTemplateChain)?
     | typeConstructor '(' type ')'
     | vector
     
 typeConstructor ::= 
       'const'
     | 'immutable'
     | 'inout'
     | 'shared'
     
 typeConstructors ::= 
     typeConstructor+
     
 typeSpecialization ::= 
       type
     | 'struct'
     | 'union'
     | 'class'
     | 'interface'
     | 'enum'
     | 'function'
     | 'delegate'
     | 'super'
     | 'const'
     | 'immutable'
     | 'inout'
     | 'shared'
     | 'return'
     | 'typedef'
     | '__parameters'
     
 typeSuffix ::= 
       '*'
     | '[' type? ']'
     | '[' assignExpression ']'
     | '[' assignExpression '..'  assignExpression ']'
     | ('delegate' | 'function') parameters memberFunctionAttribute*
     
 typeidExpression ::= 
     'typeid' '(' (type | expression) ')'
     
 typeofExpression ::= 
     'typeof' '(' (expression | 'return') ')'
     
 unaryExpression ::= 
       primaryExpression
     | '&' unaryExpression
     | '!' unaryExpression
     | '*' unaryExpression
     | '+' unaryExpression
     | '-' unaryExpression
     | '~' unaryExpression
     | '++' unaryExpression
     | '--' unaryExpression
     | newExpression
     | deleteExpression
     | castExpression
     | assertExpression
     | functionCallExpression
     | sliceExpression
     | indexExpression
     | '(' type ')' '.' identifierOrTemplateInstance
     | unaryExpression '.' identifierOrTemplateInstance
     | unaryExpression '--'
     | unaryExpression '++'
     
 unionDeclaration ::= 
       'union' Identifier templateParameters constraint? structBody
     | 'union' Identifier (structBody | ';')
     | 'union' structBody
     
 unittest ::= 
     'unittest' blockStatement
     
 variableDeclaration ::=
      autoDeclaration
     |  storageClass* type declarator (',' declarator)* ';'
     | storageClass* type Identifier '=' functionBody ';'

     
 vector ::= 
     '__vector' '(' type ')'
     
 versionCondition ::= 
     'version' '(' (INTEGER_LITERAL | Identifier | 'unittest' | 'assert') ')'
     
 versionSpecification ::= 
     'version' '=' (Identifier | INTEGER_LITERAL) ';'
     
 whileStatement ::= 
     'while' '(' expression ')' declarationOrStatement
     
 withStatement ::= 
     'with' '(' expression ')' statementNoCaseNoDefault
     
 xorExpression ::= 
       andExpression
     | xorExpression '^' andExpression

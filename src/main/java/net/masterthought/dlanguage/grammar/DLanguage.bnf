{

  parserClass="net.masterthought.dlanguage.parser.DLanguageParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="DLanguage"
  psiImplClassSuffix="Impl"
  psiPackage="net.masterthought.dlanguage.psi"
  psiImplPackage="net.masterthought.dlanguage.psi.impl"

  elementTypeHolderClass="net.masterthought.dlanguage.psi.DLanguageTypes"
  elementTypeClass="net.masterthought.dlanguage.psi.DLanguageElementType"
  tokenTypeClass="net.masterthought.dlanguage.psi.DLanguageTokenType"

  // used to attach custom methods into the classes - e.g. Identifier
  psiImplUtilClass="net.masterthought.dlanguage.psi.impl.DPsiImplUtil"


  // used to extend to use stubs
  extends("Identifier|LabeledStatement|FuncDeclaration|ClassDeclaration|InterfaceDeclaration|TemplateDeclaration|Constructor|Destructor|StructDeclaration|AliasDeclaration|ModuleDeclaration|TemplateMixinDeclaration|DeclaratorInitializer|AutoDeclarationY|UnionDeclaration|EnumDeclaration|Import")="net.masterthought.dlanguage.psi.impl.DNamedStubbedPsiElementBase<?>"
  elementTypeFactory("Identifier|LabeledStatement|FuncDeclaration|ClassDeclaration|InterfaceDeclaration|TemplateDeclaration|Constructor|Destructor|StructDeclaration|AliasDeclaration|ModuleDeclaration|TemplateMixinDeclaration|DeclaratorInitializer|AutoDeclarationY|UnionDeclaration|EnumDeclaration|Import|UnitTesting")="net.masterthought.dlanguage.psi.impl.DElementTypeFactory.factory"


  generateTokenAccessors=true

tokens = [
 KW_MODULE = "module"
 KW_IMPORT = "import"
 KW_STATIC = "static"
 KW_BOOL = "bool"
 KW_BYTE = "byte"
 KW_UBYTE = "ubyte"
 KW_SHORT = "short"
 KW_USHORT = "ushort"
 KW_INT = "int"
 KW_UINT = "uint"
 KW_LONG = "long"
 KW_ULONG = "ulong"
 KW_CHAR = "char"
 KW_WCHAR = "wchar"
 KW_DCHAR = "dchar"
 KW_FLOAT = "float"
 KW_DOUBLE = "double"
 KW_REAL = "real"
 KW_IFLOAT = "ifloat"
 KW_IDOUBLE = "idouble"
 KW_IREAL = "ireal"
 KW_CFLOAT = "cfloat"
 KW_CDOUBLE = "cdouble"
 KW_CREAL = "creal"
 KW_VOID = "void"
 KW_TYPEOF = "typeof"
 KW_CONST = "const"
 KW_IMMUTABLE = "immutable"
 KW_SHARED = "shared"
 KW_INOUT = "inout"
 KW_DELEGATE = "delegate"
 KW_FUNCTION = "function"
 KW_NOTHROW = "nothrow"
 KW_PURE = "pure"
 KW_THIS = "this"
 KW___FILE__ = "__FILE__"
 KW___MODULE__ = "__MODULE__"
 KW___LINE__ = "__LINE__"
 KW___FUNCTION__ = "__FUNCTION__"
 KW___PRETTY_FUNCTION__ = "__PRETTY_FUNCTION__"
 KW_ABSTRACT = "abstract"
 KW_ALIAS = "alias"
 KW_AUTO = "auto"
 KW_DEPRECATED = "deprecated"
 KW_ENUM = "enum"
 KW_EXTERN = "extern"
 KW_FINAL = "final"
 KW_OVERRIDE = "override"
 KW___GSHARED = "__gshared"
 KW_SCOPE = "scope"
 KW_SYNCHRONIZED = "synchronized"
 KW_RETURN = "return"
 KW_SUPER = "super"
 KW_ALIGN = "align"
 KW_PRAGMA = "pragma"
 KW_PACKAGE = "package"
 KW_PRIVATE = "private"
 KW_PROTECTED = "protected"
 KW_PUBLIC = "public"
 KW_EXPORT = "export"
 KW_DELETE = "delete"
 KW_NULL = "null"
 KW_TRUE = "true"
 KW_FALSE = "false"
 KW_NEW = "new"
 KW_TYPEID = "typeid"
 KW_IS = "is"
 KW_NOT_IS = "!is"
 KW_STRUCT = "struct"
 KW_UNION = "union"
 KW_CLASS = "class"
 KW_INTERFACE = "interface"
 KW___PARAMETERS = "__parameters"
 KW_IN = "in"
 KW_NOT_IN = "!in"
 KW_ASM = "asm"
 KW_ASSERT = "assert"
 KW_CASE = "case"
 KW_CAST = "cast"
 KW_REF = "ref"
 KW_BREAK = "break"
 KW_CONTINUE = "continue"
 KW_DO = "do"
 KW_ELSE = "else"
 KW_FOR = "for"
 KW_FOREACH = "foreach"
 KW_FOREACH_REVERSE = "foreach_reverse"
 KW_GOTO = "goto"
 KW_IF = "if"
 KW_CATCH = "catch"
 KW_FINALLY = "finally"
 KW_SWITCH = "switch"
 KW_THROW = "throw"
 KW_TRY = "try"
 KW_DEFAULT = "default"
 KW_WHILE = "while"
 KW_WITH = "with"
 KW_VERSION = "version"
 KW_DEBUG = "debug"
 KW_MIXIN = "mixin"
 KW_INVARIANT = "invariant"
 KW_BODY = "body"
 KW_TEMPLATE = "template"
 KW_LAZY = "lazy"
 KW_OUT = "out"
 KW_NOGC = "nogc"
 KW___TRAITS = "__traits"
 KW_UNITTEST = "unittest"
 OP_SCOLON = ";"
 OP_COLON = ":"
 OP_EQ = "="
 OP_COMMA = ","
 OP_PAR_LEFT = "("
 OP_PAR_RIGHT = ")"
 OP_BRACKET_LEFT = "["
 OP_BRACKET_RIGHT = "]"
 OP_BRACES_LEFT = "{"
 OP_BRACES_RIGHT = "}"
 OP_ASTERISK = "*"
 OP_DDOT = ".."
 OP_TRIPLEDOT = "..."
 OP_AT = "@"
 OP_PLUS_EQ = "+="
 OP_MINUS_EQ = "-="
 OP_MUL_EQ = "*="
 OP_DIV_EQ = "/="
 OP_MOD_EQ = "%="
 OP_AND_EQ = "&="
 OP_OR_EQ = "|="
 OP_XOR_EQ = "^="
 OP_TILDA_EQ = "~="
 OP_SH_LEFT_EQ = "<<="
 OP_SH_RIGHT_EQ = ">>="
 OP_USH_RIGHT_EQ = ">>>="
 OP_POW_EQ = "^^="
 OP_QUEST = "?"
 OP_BOOL_OR = "||"
 OP_BOOL_AND = "&&"
 OP_OR = "|"
 OP_XOR = "^"
 OP_SH_LEFT = "<<"
 OP_SH_RIGHT = ">>"
 OP_USH_RIGHT = ">>>"
 OP_PLUS = "+"
 OP_MINUS = "-"
 OP_TILDA = "~"
 OP_DIV = "/"
 OP_MOD = "%"
 OP_AND = "&"
 OP_PLUS_PLUS = "++"
 OP_MINUS_MINUS = "--"
 OP_NOT = "!"
 OP_POW = "^^"
 OP_DOLLAR = "$"
 OP_EQ_EQ = "=="
 OP_NOT_EQ = "!="
 OP_LESS = "<"
 OP_LESS_EQ = "<="
 OP_GT = ">"
 OP_GT_EQ = ">="
 OP_UNORD = "!<>="
 OP_UNORD_EQ = "!<>"
 OP_LESS_GR = "<>"
 OP_LESS_GR_EQ = "<>="
 OP_NOT_GR = "!>"
 OP_NOT_GR_EQ = "!>="
 OP_NOT_LESS = "!<"
 OP_NOT_LESS_EQ = "!<="
 OP_LAMBDA_ARROW = "=>"
 OP_DOT = "."
 SHEBANG = "shebang"

 LINE_COMMENT="LINE_COMMENT"
 BLOCK_COMMENT="BLOCK_COMMENT"
 NESTING_BLOCK_COMMENT="NESTING_BLOCK_COMMENT"

// Comment these back in when playing with Live Preview
// ------------------------
ID = "regexp:\w+"
space='regexp:\s+'
line_comment="regexp://.*"
block_comment="regexp:/\*(.|\n)*\*/"
DOUBLE_QUOTED_STRING = 'regexp:\"([^\\"]|((\\"|\\\?|\\\|\\0|\\a|\\b|\\f|\\n|\\r|\\t|\\v)|(\\x[0-9abcdefABCDEF_]{2})|(\\[0-7])|(\\[0-7]{2})|(\\[0-7]{3})|(\\u[0-9abcdefABCDEF_]{4})|(\\U[0-9abcdefABCDEF_]{8})|(\\&([a-zA-Z_])([a-zA-Z0-9_])*;)))*\"[cwd]*'
// ------------------------

 ]

}

dFile ::= item_*

private item_ ::= (ModuleDeclaration | DeclDefs | Statement | SHEBANG) {
    recoverWhile = item_recover
}

private item_recover ::= !(ModuleDeclaration | DeclDefs | Statement | SHEBANG)

Identifier ::= ID {
    methods=[getName getNameIdentifier getReference setName getPresentation]
    stubClass="net.masterthought.dlanguage.stubs.DLanguageIdentifierStub"
    implements = ["net.masterthought.dlanguage.psi.interfaces.DNamedElement"]
    }

StringLiteral  ::= (WYSIWYG_STRING|ALTERNATE_WYSIWYG_STRING|DOUBLE_QUOTED_STRING|HEX_STRING|DELIMITED_STRING)

// Module

ModuleDeclaration ::=
    Attribute? 'module' ModuleFullyQualifiedName ';'{
        methods=[getName getFullName getNameIdentifier getReference setName getPresentation isSomeVisibility]
        stubClass="net.masterthought.dlanguage.stubs.DLanguageModuleDeclarationStub"
        implements = ["net.masterthought.dlanguage.psi.interfaces.DNamedElement" "net.masterthought.dlanguage.psi.interfaces.containers.GlobalDeclarationContainer" "net.masterthought.dlanguage.psi.interfaces.HasVisibility" "net.masterthought.dlanguage.psi.interfaces.Declaration" ]

    }

ModuleFullyQualifiedName ::=
    Identifier ['.' ModuleFullyQualifiedName] {
        recoverWhile = module_name_recover
        pin = 1
    }

private module_name_recover ::= !(/*Identifier*/ ':' | ',' |  ';')

// Import

ImportDeclaration ::=
    RegularImport |
    StaticImport

private RegularImport ::=
    'import' ImportList ';' //{pin = 1 recoverWhile=import_recover}

private StaticImport ::=
    'static' 'import' ImportList ';'//{ pin=2 recoverWhile=import_recover}

//private import_recover ::= item_recover

ImportList ::=
    Import (':' ImportBindList | ',' ImportList)?

Import ::=
    (Identifier '=')? ModuleFullyQualifiedName{
     methods=[getName getNameIdentifier getReference setName getPresentation isSomeVisibility]
     stubClass="net.masterthought.dlanguage.stubs.DLanguageImportDeclarationStub"
     implements = ["net.masterthought.dlanguage.psi.interfaces.DNamedElement" "net.masterthought.dlanguage.psi.interfaces.HasVisibility"]
  }

ImportBindList ::=
    ImportBind (',' ImportBindList)?

ImportBind ::=
    Identifier ('=' Identifier)?

DeclDefs ::= DeclDef [DeclDefs]

//order matters
DeclDef ::=
    (AttributeSpecifier
    | Declaration
    | Postblit
    | Constructor
    | Destructor
    | Allocator
    | Deallocator
    | Invariant
    | UnitTesting
    | AliasThis
    | StaticConstructor
    | StaticDestructor
    | SharedStaticConstructor
    | SharedStaticDestructor
    | ConditionalDeclaration
    | DebugSpecification
    | VersionSpecification
    | StaticAssert
    | TemplateDeclaration
    | TemplateMixinDeclaration
    | TemplateMixin
    | MixinDeclaration
    | StaticIfCondition
    | StaticElseCondition
    | ';'
    )

MixinDeclaration ::=
    'mixin' '(' (TemplateInstance | AssignExpression) ')' ';'{
     methods = [getName ] // the getTemplate method should resolve the template which is being mixed in.
     implements = ["net.masterthought.dlanguage.psi.interfaces.Mixin"]
     }

Type ::=
    TypeCtors? BasicType BasicType2?

TypeCtors ::=
    TypeCtor [TypeCtors]

TypeCtor ::=
    'const'
    | 'immutable'
    | 'inout'
    | 'shared'

BasicType ::=
    BasicTypeX
    | ('.')? IdentifierList
    | Typeof ('.' IdentifierList)?
    | '(' Type ')'
    | TypeVector

BasicTypeX ::=
     'bool'
    | 'byte'
    | 'ubyte'
    | 'short'
    | 'ushort'
    | 'int'
    | 'uint'
    | 'long'
    | 'ulong'
    | 'char'
    | 'wchar'
    | 'dchar'
    | 'float'
    | 'double'
    | 'real'
    | 'ifloat'
    | 'idouble'
    | 'ireal'
    | 'cfloat'
    | 'cdouble'
    | 'creal'
    | 'void'

BasicType2 ::=
    BasicType2X BasicType2?

BasicType2X ::=
    '*'
    | '[' AssignExpression ']'
    | '[' AssignExpression '..' AssignExpression ']'
    | '[' Type? ']'
    | 'delegate' Parameters MemberFunctionAttributes?
    | 'function' Parameters FunctionAttributes?

IdentifierList ::=
//    Identifier ('.' IdentifierList)?
     Identifier TemplateInstance? ['.' IdentifierList]
    |  Identifier '[' AssignExpression ']' '.' IdentifierList

Typeof ::=
    'typeof' '(' (Expression | 'return') ')'

TypeVector ::=
    '__vector' '(' Type ')'

Expression ::=
    CommaExpression

CommaExpression ::=
    AssignExpression (',' CommaExpression)?

AssignExpression ::=
   ConditionalExpression [ ( '='
                              | '+='
                              | '-='
                              | '*='
                              | '/='
                              | '%='
                              | '&='
                              | '|='
                              | '^='
                              | '~='
                              | '<<='
                              | '>>='
                              | '>>>='
                              | '^^=') AssignExpression]

ConditionalExpression ::=
   OrOrExpression ['?' Expression ':' ConditionalExpression]

OrOrExpression ::= AndAndExpression [ '||' OrOrExpression]

AndAndExpression ::=
    ('&&')? ( OrExpression | CmpExpression ) [ AndAndExpression ]

OrExpression ::=
    XorExpression [OrExpression]

XorExpression ::= AndExpression [ '^' XorExpression ]

AndExpression ::= ShiftExpression [ '&' AndExpression ]

CmpExpression ::=
    ShiftExpression
    | EqualExpression
    | IdentityExpression
    | RelExpression
    | InExpression

EqualExpression ::=
     ('==' | '!=') [ShiftExpression]

IdentityExpression ::=
     ('is'|'!is') ShiftExpression

RelExpression ::=
    ('<'
    | '<='
    | '>'
    | '>='
    | '!<>='
    | '!<>'
    | '<>'
    | '<>='
    | '!>'
    | '!>='
    | '!<'
    | '!<=') ShiftExpression

InExpression ::=
    ('in'| '!in') ShiftExpression

ShiftExpression ::= AddExpression [('<<' | '>>' | '>>>') ShiftExpression]

AddExpression ::=
    MulExpression [ ('+' | '-' | '~') AddExpression]

MulExpression ::= UnaryExpression [ ('*' | '/' | '%') MulExpression]

UnaryExpression ::=
     ('&'
    | '++'
    | '|'
    | '^^'
    | '--'
    | '*'
    | '-'
    | '+'
    | '!'
    | '~') [UnaryExpression]
    | '(' Type ')' '.' Identifier
    | '(' Type ')' '.' TemplateInstance
    | DeleteExpression
    | CastExpression
    | PowExpression

NewExpression ::=
    'new' AllocatorArguments? Type
    | NewExpressionWithArgs

NewExpressionWithArgs ::=
    'new' AllocatorArguments? Type '[' AssignExpression ']'
   | 'new' AllocatorArguments? Type ('(' ArgumentList? ')')?
   | NewAnonClassExpression

AllocatorArguments ::=
    '(' ArgumentList? ')'

ArgumentList ::=
   AssignExpression [','  ArgumentList]

NewAnonClassExpression ::=
    'new' AllocatorArguments? 'class' ClassArguments? SuperClass? Interfaces? AggregateBody

ClassArguments ::=
    '(' ArgumentList? ')'

DeleteExpression ::=
    'delete' UnaryExpression

CastExpression ::=
    'cast' '(' Type ')' UnaryExpression
    | 'cast' '(' TypeCtors? ')' UnaryExpression

PowExpression ::= PostfixExpression ['^^' UnaryExpression PowExpression]

PostfixExpression ::=
    PrimaryExpression
    | '.' Identifier [PostfixExpression]
    | '.' TemplateInstance [PostfixExpression]
    | '.' NewExpression [PostfixExpression]
    | '++' [PostfixExpression]
    |  '--' [PostfixExpression]
    | '(' ArgumentList? ')' [PostfixExpression]
    | TypeCtors? BasicType '(' ArgumentList? ')' [PostfixExpression]
    | IndexExpression
    | SliceExpression

IndexExpression ::=
     '[' ArgumentList ']' [PostfixExpression]

SliceExpression ::=
     '[' ']' [PostfixExpression]
    |  '[' MultipleAssign ']' [PostfixExpression]

MultipleAssign ::=
 ((AssignExpression '..' AssignExpression) | AssignExpression) [',' MultipleAssign ]

PrimaryExpression ::=
     ('.')? (TemplateInstance | Identifier)
    | 'this'
    | 'super'
    | 'null'
    | 'true'
    | 'false'
    | '$'
    | INTEGER_LITERAL
    | FLOAT_LITERAL
    | CHARACTER_LITERAL
    | StringLiterals
    | ArrayLiteral
    | AssocArrayLiteral
    | FunctionLiteral
    | AssertExpression
    | MixinExpression
    | ImportExpression
    | NewExpressionWithArgs
    | BasicTypeX '.' Identifier
    | Typeof
    | TypeidExpression
    | IsExpression
    | '(' Expression ')'
    | TraitsExpression
    | SpecialKeyword

StringLiterals ::= StringLiteral [StringLiterals]

ArrayLiteral ::=
    '[' ArgumentList? ']'

AssocArrayLiteral ::=
    '[' KeyValuePairs ']'

KeyValuePairs ::=
    KeyValuePair [(',')? KeyValuePairs]

KeyValuePair ::=
    AssignExpression ':' AssignExpression

FunctionLiteral ::=
     'function' Type? ParameterAttributes? FunctionLiteralBody?
    | 'delegate' Type? ParameterMemberAttributes? FunctionLiteralBody?
    | ParameterMemberAttributes FunctionLiteralBody?
    | FunctionLiteralBody
    | Lambda


ParameterAttributes ::=
    Parameters FunctionAttributes?

ParameterMemberAttributes ::=
    Parameters MemberFunctionAttributes?

FunctionLiteralBody ::=
    BlockStatement |
    FunctionContracts BodyStatement?

Lambda ::=
    'function' Type? ParameterAttributes '=>' AssignExpression
    | 'delegate' Type? ParameterMemberAttributes '=>' AssignExpression
    | ParameterMemberAttributes '=>' AssignExpression
    | Identifier? '=>' AssignExpression

AssertExpression ::=
    'assert' '(' AssignExpression (',' AssignExpression)? ')'

MixinExpression ::=
    'mixin' '(' ( AssignExpression) ')'{
     methods = [ getName ] // the getTemplate method should resolve the template which is being mixed in.
     implements = ["net.masterthought.dlanguage.psi.interfaces.Mixin"]
     }

ImportExpression ::=
    'import' '(' AssignExpression ')'

TypeidExpression ::=
    'typeid' '(' Type ')'
    | 'typeid' '(' Expression ')'

IsExpression ::= ('is' | '!is') IsExpressionSuffix

private IsExpressionSuffix ::=
     '(' Type ')'
    | '(' Type ':' TypeSpecialization ')'
    | '(' Type '==' TypeSpecialization ')'
    | '(' Type ':' TypeSpecialization ',' TemplateParameterList ')'
    | '(' Type '==' TypeSpecialization ',' TemplateParameterList ')'
    | '(' Type Identifier ')'
    | '(' Type Identifier ':' TypeSpecialization ')'
    | '(' Type Identifier '==' TypeSpecialization ')'
    | '(' Type Identifier ':' TypeSpecialization ',' TemplateParameterList ')'
    | '(' Type Identifier '==' TypeSpecialization ',' TemplateParameterList ')'

TypeSpecialization ::=
    Type
    | 'struct'
    | 'union'
    | 'class'
    | 'interface'
    | 'enum'
    | 'function'
    | 'delegate'
    | 'super'
    | 'const'
    | 'immutable'
    | 'inout'
    | 'shared'
    | 'return'
    | '__parameters'

TraitsExpression ::=
    '__traits' ('(' TraitsKeyword ',' TraitsArguments ')')?
//    '__traits' '(' TraitsKeyword ',' TraitsArguments ')'

TraitsKeyword ::=
    'isAbstractClass'
    | 'isArithmetic'
    | 'isAssociativeArray'
    | 'isFinalClass'
    | 'isPOD'
    | 'isNested'
    | 'isFloating'
    | 'isIntegral'
    | 'isScalar'
    | 'isStaticArray'
    | 'isUnsigned'
    | 'isVirtualFunction'
    | 'isVirtualMethod'
    | 'isAbstractFunction'
    | 'isFinalFunction'
    | 'isStaticFunction'
    | 'isOverrideFunction'
    | 'isRef'
    | 'isOut'
    | 'isLazy'
    | 'hasMember'
    | 'identifier'
    | 'getAliasThis'
    | 'getAttributes'
    | 'getFunctionAttributes'
    | 'getMember'
    | 'getOverloads'
    | 'getProtection'
    | 'getPointerBitmap'
    | 'isSomeVisibility'
    | 'getVirtualFunctions'
    | 'getVirtualMethods'
    | 'getUnitTests'
    | 'parent'
    | 'classInstanceSize'
    | 'getVirtualIndex'
    | 'allMembers'
    | 'derivedMembers'
    | 'isSame'
    | 'compiles'

TraitsArguments ::=
    TraitsArgument (',' TraitsArguments)?

TraitsArgument ::=
    AssignExpression
    | Type

SpecialKeyword ::=
     '__FILE__'
    | '__MODULE__'
    | '__LINE__'
    | '__FUNCTION__'
    | '__PRETTY_FUNCTION__'

// Statement

Statement ::=
    ';'
    | NonEmptyStatement
    | BlockStatement

NonEmptyStatement ::=
    NonEmptyStatementNoCaseNoDefault
    | CaseStatement
    | CaseRangeStatement
    | DefaultStatement

NonEmptyStatementNoCaseNoDefault ::=
    LabeledStatement
    | DeclarationStatement
    | ExpressionStatement
    | IfStatement
    | WhileStatement
    | DoStatement
    | ForStatement
    | ForeachStatement
    | SwitchStatement
    | FinalSwitchStatement
    | ContinueStatement
    | BreakStatement
    | ReturnStatement
    | GotoStatement
    | WithStatement
    | SynchronizedStatement
    | TryStatement
    | ScopeGuardStatement
    | ThrowStatement
    | AsmStatement
    | PragmaStatement
    | MixinStatement
    | ForeachRangeStatement
    | ConditionalStatement
    | StaticAssert
    | TemplateMixin
    | ImportDeclaration

ScopeStatement ::=
    NonEmptyStatement
    | BlockStatement

LabeledStatement ::=
    Identifier ':' Statement? {
        methods=[getName getNameIdentifier getReference setName getPresentation ]
        stubClass="net.masterthought.dlanguage.stubs.DLanguageLabeledStatementStub"
        implements = ["net.masterthought.dlanguage.psi.interfaces.DNamedElement" "net.masterthought.dlanguage.psi.interfaces.containers.StatementContainer" ]
    }


BlockStatement ::=
 '{' StatementList? '}'

StatementList ::=
    Statement [StatementList]

ExpressionStatement ::=
    Expression ';'?

DeclarationStatement ::=
    StorageClasses? Declaration

IfStatement ::=
    'if' '(' IfCondition ')' ThenStatement ('else' ElseStatement)?

IfCondition ::=
    Expression
    | 'auto' Identifier '=' Expression
    | TypeCtors Identifier '=' Expression
    | TypeCtors? BasicType Declarator '=' Expression

ThenStatement ::=
    ScopeStatement

ElseStatement ::=
    ScopeStatement

WhileStatement ::=
    'while' '(' Expression ')' ScopeStatement

DoStatement ::=
    'do' ScopeStatement 'while' '(' Expression ')' ';'

ForStatement ::=
    'for' '(' Initialize Test? ';' Increment? ')' ScopeStatement

Initialize ::=
   Statement
   | ';'

Test ::=
    Expression

Increment ::=
    Expression

ForeachStatement ::=
    Foreach '(' ForeachTypeList ';' ForeachAggregate ')' Statement

Foreach ::=
    'foreach'
    | 'foreach_reverse'

ForeachTypeList ::=
    ForeachType [',' ForeachTypeList]

ForeachType ::=
   Type? ForeachTypeAttributes? Identifier
   | ForeachTypeAttributes? Type? Identifier
   | Identifier

ForeachTypeAttributes ::=
    ForeachTypeAttribute [ForeachTypeAttributes]

ForeachTypeAttribute ::=
    'ref'
    | TypeCtor

ForeachAggregate ::=
    Expression

ForeachRangeStatement ::=
    Foreach '(' ForeachType ';' LwrExpression '..' UprExpression ')' ScopeStatement

LwrExpression ::=
    Expression

UprExpression ::=
    Expression

SwitchStatement ::=
    'switch' '(' Expression ')' ScopeStatement

CaseStatement ::=
    'case' ArgumentList ':' ScopeStatementList?

CaseRangeStatement ::=
    'case' FirstExp ':' '..' 'case' LastExp ':' ScopeStatementList

FirstExp ::=
    AssignExpression

LastExp ::=
    AssignExpression

DefaultStatement ::=
    'default' ':' ScopeStatementList

ScopeStatementList ::=
    StatementListNoCaseNoDefault

StatementListNoCaseNoDefault ::=
    StatementNoCaseNoDefault [StatementListNoCaseNoDefault]

StatementNoCaseNoDefault ::=
    NonEmptyStatementNoCaseNoDefault
    | BlockStatement

FinalSwitchStatement ::=
    'final' 'switch' '(' Expression ')' ScopeStatement

ContinueStatement ::=
    'continue' Identifier? ';'

BreakStatement ::=
    'break' Identifier? ';'

ReturnStatement ::=
    'return' Expression? ';'

GotoStatement ::=
    'goto' Identifier ';'
    | 'goto' 'default' ';'
    | 'goto' 'case' ';'
    | 'goto' 'case' Expression ';'

WithStatement ::=
    'with' '(' Expression ')' ScopeStatement
    | 'with' '(' Symbol ')' ScopeStatement
    | 'with' '(' TemplateInstance ')' ScopeStatement

SynchronizedStatement ::=
    'synchronized' ScopeStatement
    | 'synchronized' '(' Expression ')' ScopeStatement

TryStatement ::=
    'try' ScopeStatement Catches
    | 'try' ScopeStatement Catches FinallyStatement
    | 'try' ScopeStatement FinallyStatement

Catches ::=
     Catch [Catches]
     | LastCatch

LastCatch ::=
    'catch' Statement

Catch ::=
    'catch' '(' CatchParameter ')' Statement

CatchParameter ::=
    BasicType Identifier

FinallyStatement ::=
    'finally' Statement

ThrowStatement ::=
    'throw' Expression ';'

ScopeGuardStatement ::=
    'scope' '(' 'exit' ')' Statement
    | 'scope' '(' 'success' ')' Statement
    | 'scope' '(' 'failure' ')' Statement

PragmaStatement ::=
    Pragma Statement

MixinStatement ::=
    'mixin' '(' ( AssignExpression) ')' ';'{
     methods = [ getName] // the getTemplate method should resolve the template which is being mixed in.
     implements = ["net.masterthought.dlanguage.psi.interfaces.Mixin"]
     }

AsmStatement ::=
    'asm' FunctionAttributes? '{' AsmInstructionList? '}'

AsmInstructionList ::=
   AsmInstruction ';' AsmInstructionList?

AsmInstruction ::=
    Identifier ':' AsmInstruction?
    | 'align' IntegerExpression
    | 'even'
    | 'naked'
    | 'db' Operands
    | 'ds' Operands
    | 'di' Operands
    | 'dl' Operands
    | 'df' Operands
    | 'dd' Operands
    | 'de' Operands
    | Opcode Operands?

Operands ::=
    Operand [',' Operands]

IntegerExpression ::=
    INTEGER_LITERAL
   |  Identifier

Register ::=
    'AL' 'AH' 'AX' 'EAX'
    | 'BL' 'BH' 'BX' 'EBX'
    | 'CL' 'CH' 'CX' 'ECX'
    | 'DL' 'DH' 'DX' 'EDX'
    | 'BP' 'EBP'
    | 'SP' 'ESP'
    | 'DI' 'EDI'
    | 'SI' 'ESI'
    | 'ES' 'CS SS DS GS FS'
    | 'CR0' 'CR2' 'CR3' 'CR4'
    | 'DR0' 'DR1' 'DR2' 'DR3' 'DR6' 'DR7'
    | 'TR3' 'TR4' 'TR5' 'TR6' 'TR7'
    | 'ST'
    | 'ST(0)' 'ST(1)' 'ST(2)' 'ST(3)' 'ST(4)' 'ST(5)' 'ST(6)' 'ST(7)'
    | 'MM0'  'MM1'  'MM2'  'MM3'  'MM4'  'MM5'  'MM6'  'MM7'
    | 'XMM0' 'XMM1' 'XMM2' 'XMM3' 'XMM4' 'XMM5' 'XMM6' 'XMM7'
    | 'AL' | 'AH' | 'AX' | 'EAX'
    | 'BL' | 'BH' | 'BX' | 'EBX'
    | 'CL' | 'CH' | 'CX' | 'ECX'
    | 'DL' | 'DH' | 'DX' | 'EDX'
    | 'BP' | 'EBP'
    | 'SP' | 'ESP'
    | 'DI' | 'EDI'
    | 'SI' | 'ESI'
    | 'ES' | 'CS SS DS GS FS'
    | 'CR0' | 'CR2' | 'CR3' | 'CR4'
    | 'DR0' | 'DR1' | 'DR2' | 'DR3' | 'DR6' | 'DR7'
    | 'TR3' | 'TR4' | 'TR5' | 'TR6' | 'TR7'
    | 'ST(0)' | 'ST(1)' | 'ST(2)' | 'ST(3)' | 'ST(4)' | 'ST(5)' | 'ST(6)' | 'ST(7)'
    | 'MM0' | 'MM1' | 'MM2' | 'MM3' | 'MM4' | 'MM5' | 'MM6' | 'MM7'
    | 'XMM0' | 'XMM1' | 'XMM2' | 'XMM3' | 'XMM4' | 'XMM5' | 'XMM6' | 'XMM7'

Register64 ::=
    'RAX'  'RBX'  'RCX'  'RDX'
    | 'BPL'  'RBP'
    | 'SPL'  'RSP'
    | 'DIL'  'RDI'
    | 'SIL'  'RSI'
    | 'R8B'  'R8W'  'R8D'  'R8'
    | 'R9B'  'R9W'  'R9D'  'R9'
    | 'R10B' 'R10W' 'R10D' 'R10'
    | 'R11B' 'R11W' 'R11D' 'R11'
    | 'R12B' 'R12W' 'R12D' 'R12'
    | 'R13B' 'R13W' 'R13D' 'R13'
    | 'R14B' 'R14W' 'R14D' 'R14'
    | 'R15B' 'R15W' 'R15D' 'R15'
    | 'XMM8' 'XMM9' 'XMM10' 'XMM11' 'XMM12' 'XMM13' 'XMM14' 'XMM15'
    | 'YMM0' 'YMM1' 'YMM2' 'YMM3' 'YMM4' 'YMM5' 'YMM6' 'YMM7'
    | 'YMM8' 'YMM9' 'YMM10' 'YMM11' 'YMM12' 'YMM13' 'YMM14' 'YMM15'

Operand ::=
    AsmExp

AsmExp ::=
  AsmLogOrExp ('?' AsmExp ':' AsmExp)?

AsmLogOrExp ::=
    AsmLogAndExp ['||' AsmLogOrExp]

AsmLogAndExp ::=
    AsmOrExp ['&&' AsmLogAndExp]

AsmOrExp ::=
    AsmXorExp ['|' AsmOrExp]

AsmXorExp ::=
    AsmAndExp [ '^' AsmXorExp ]

AsmAndExp ::=
   AsmEqualExp ['&' AsmAndExp]

AsmEqualExp ::=
  AsmRelExp [ ('==' | '!=' ) AsmEqualExp]

AsmRelExp ::=
   AsmShiftExp [ ('<' | '<=' | '>' | '>=' ) AsmRelExp]

AsmShiftExp ::=
    AsmAddExp [ ('<<' | '>>' | '>>>') AsmShiftExp ]

AsmAddExp ::=
 AsmMulExp [ ('+' | '-') AsmAddExp ]

AsmMulExp ::=
   AsmBrExp [ ('*' | '/' | '%') AsmMulExp]

AsmBrExp ::=
       AsmUnaExp ['[' AsmExp ']']

AsmUnaExp ::=
    AsmTypePrefix AsmExp
    | 'offsetof' AsmExp
    | 'seg' AsmExp
    | '+' AsmUnaExp
    | '-' AsmUnaExp
    | '!' AsmUnaExp
    | '~' AsmUnaExp
    | AsmPrimaryExp

AsmPrimaryExp ::=
    INTEGER_LITERAL
    | StringLiteral
    | FLOAT_LITERAL
    | '__LOCAL_SIZE'
    | '$'
    | Register (':' AsmExp)?
    | Register64 (':' AsmExp)?
    | DotIdentifier
    | 'this'

DotIdentifier ::=
    Identifier ['.' DotIdentifier]

AsmTypePrefix ::=
    'near' 'ptr'
    | 'far' 'ptr'
    | 'byte' 'ptr'
    | 'short' 'ptr'
    | 'int' 'ptr'
    | 'word' 'ptr'
    | 'dword' 'ptr'
    | 'qword' 'ptr'
    | 'float' 'ptr'
    | 'double' 'ptr'
    | 'real' 'ptr'
    | 'real ptr'

Opcode ::=
 'aaa'
| 'aad'
| 'aam'
| 'aas'
| 'adc'
| 'add'
| 'addpd'
| 'addps'
| 'addsd'
| 'addss'
| 'and'
| 'andnpd'
| 'andnps'
| 'andpd'
| 'andps'
| 'arpl'
| 'bound'
| 'bsf'
| 'bsr'
| 'bswap'
| 'bt'
| 'btc'
| 'btr'
| 'bts'
| 'call'
| 'cbw'
| 'cdq'
| 'clc'
| 'cld'
| 'clflush'
| 'cli'
| 'clts'
| 'cmc'
| 'cmova'
| 'cmovae'
| 'cmovb'
| 'cmovbe'
| 'cmovc'
| 'cmove'
| 'cmovg'
| 'cmovge'
| 'cmovl'
| 'cmovle'
| 'cmovna'
| 'cmovnae'
| 'cmovnb'
| 'cmovnbe'
| 'cmovnc'
| 'cmovne'
| 'cmovng'
| 'cmovnge'
| 'cmovnl'
| 'cmovnle'
| 'cmovno'
| 'cmovnp'
| 'cmovns'
| 'cmovnz'
| 'cmovo'
| 'cmovp'
| 'cmovpe'
| 'cmovpo'
| 'cmovs'
| 'cmovz'
| 'cmp'
| 'cmppd'
| 'cmpps'
| 'cmps'
| 'cmpsb'
| 'cmpsd'
| 'cmpss'
| 'cmpsw'
| 'cmpxchg'
| 'cmpxchg8b'
| 'cmpxchg16b'
| 'comisd'
| 'comiss'
| 'cpuid'
| 'cvtdq2pd'
| 'cvtdq2ps'
| 'cvtpd2dq'
| 'cvtpd2pi'
| 'cvtpd2ps'
| 'cvtpi2pd'
| 'cvtpi2ps'
| 'cvtps2dq'
| 'cvtps2pd'
| 'cvtps2pi'
| 'cvtsd2si'
| 'cvtsd2ss'
| 'cvtsi2sd'
| 'cvtsi2ss'
| 'cvtss2sd'
| 'cvtss2si'
| 'cvttpd2dq'
| 'cvttpd2pi'
| 'cvttps2dq'
| 'cvttps2pi'
| 'cvttsd2si'
| 'cvttss2si'
| 'cwd'
| 'cwde'
| 'da'
| 'daa'
| 'das'
| 'db'
| 'dd'
| 'de'
| 'dec'
| 'df'
| 'di'
| 'div'
| 'divpd'
| 'divps'
| 'divsd'
| 'divss'
| 'dl'
| 'dq'
| 'ds'
| 'dt'
| 'dw'
| 'emms'
| 'enter'
| 'f2xm1'
| 'fabs'
| 'fadd'
| 'faddp'
| 'fbld'
| 'fbstp'
| 'fchs'
| 'fclex'
| 'fcmovb'
| 'fcmovbe'
| 'fcmove'
| 'fcmovnb'
| 'fcmovnbe'
| 'fcmovne'
| 'fcmovnu'
| 'fcmovu'
| 'fcom'
| 'fcomi'
| 'fcomip'
| 'fcomp'
| 'fcompp'
| 'fcos'
| 'fdecstp'
| 'fdisi'
| 'fdiv'
| 'fdivp'
| 'fdivr'
| 'fdivrp'
| 'feni'
| 'ffree'
| 'fiadd'
| 'ficom'
| 'ficomp'
| 'fidiv'
| 'fidivr'
| 'fild'
| 'fimul'
| 'fincstp'
| 'finit'
| 'fist'
| 'fistp'
| 'fisub'
| 'fisubr'
| 'fld'
| 'fld1'
| 'fldcw'
| 'fldenv'
| 'fldl2e'
| 'fldl2t'
| 'fldlg2'
| 'fldln2'
| 'fldpi'
| 'fldz'
| 'fmul'
| 'fmulp'
| 'fnclex'
| 'fndisi'
| 'fneni'
| 'fninit'
| 'fnop'
| 'fnsave'
| 'fnstcw'
| 'fnstenv'
| 'fnstsw'
| 'fpatan'
| 'fprem'
| 'fprem1'
| 'fptan'
| 'frndint'
| 'frstor'
| 'fsave'
| 'fscale'
| 'fsetpm'
| 'fsin'
| 'fsincos'
| 'fsqrt'
| 'fst'
| 'fstcw'
| 'fstenv'
| 'fstp'
| 'fstsw'
| 'fsub'
| 'fsubp'
| 'fsubr'
| 'fsubrp'
| 'ftst'
| 'fucom'
| 'fucomi'
| 'fucomip'
| 'fucomp'
| 'fucompp'
| 'fwait'
| 'fxam'
| 'fxch'
| 'fxrstor'
| 'fxsave'
| 'fxtract'
| 'fyl2x'
| 'fyl2xp1'
| 'hlt'
| 'idiv'
| 'imul'
| 'in'
| 'inc'
| 'ins'
| 'insb'
| 'insd'
| 'insw'
| 'int'
| 'into'
| 'invd'
| 'invlpg'
| 'iret'
| 'iretd'
| 'ja'
| 'jae'
| 'jb'
| 'jbe'
| 'jc'
| 'jcxz'
| 'je'
| 'jecxz'
| 'jg'
| 'jge'
| 'jl'
| 'jle'
| 'jmp'
| 'jna'
| 'jnae'
| 'jnb'
| 'jnbe'
| 'jnc'
| 'jne'
| 'jng'
| 'jnge'
| 'jnl'
| 'jnle'
| 'jno'
| 'jnp'
| 'jns'
| 'jnz'
| 'jo'
| 'jp'
| 'jpe'
| 'jpo'
| 'js'
| 'jz'
| 'lahf'
| 'lar'
| 'ldmxcsr'
| 'lds'
| 'lea'
| 'leave'
| 'les'
| 'lfence'
| 'lfs'
| 'lgdt'
| 'lgs'
| 'lidt'
| 'lldt'
| 'lmsw'
| 'lock'
| 'lods'
| 'lodsb'
| 'lodsd'
| 'lodsw'
| 'loop'
| 'loope'
| 'loopne'
| 'loopnz'
| 'loopz'
| 'lsl'
| 'lss'
| 'ltr'
| 'maskmovdqu'
| 'maskmovq'
| 'maxpd'
| 'maxps'
| 'maxsd'
| 'maxss'
| 'mfence'
| 'minpd'
| 'minps'
| 'minsd'
| 'minss'
| 'mov'
| 'movapd'
| 'movaps'
| 'movd'
| 'movdq2q'
| 'movdqa'
| 'movdqu'
| 'movhlps'
| 'movhpd'
| 'movhps'
| 'movlhps'
| 'movlpd'
| 'movlps'
| 'movmskpd'
| 'movmskps'
| 'movntdq'
| 'movnti'
| 'movntpd'
| 'movntps'
| 'movntq'
| 'movq'
| 'movq2dq'
| 'movs'
| 'movsb'
| 'movsd'
| 'movss'
| 'movsw'
| 'movsx'
| 'movupd'
| 'movups'
| 'movzx'
| 'mul'
| 'mulpd'
| 'mulps'
| 'mulsd'
| 'mulss'
| 'neg'
| 'nop'
| 'not'
| 'or'
| 'orpd'
| 'orps'
| 'out'
| 'outs'
| 'outsb'
| 'outsd'
| 'outsw'
| 'packssdw'
| 'packsswb'
| 'packuswb'
| 'paddb'
| 'paddd'
| 'paddq'
| 'paddsb'
| 'paddsw'
| 'paddusb'
| 'paddusw'
| 'paddw'
| 'pand'
| 'pandn'
| 'pavgb'
| 'pavgw'
| 'pcmpeqb'
| 'pcmpeqd'
| 'pcmpeqw'
| 'pcmpgtb'
| 'pcmpgtd'
| 'pcmpgtw'
| 'pextrw'
| 'pinsrw'
| 'pmaddwd'
| 'pmaxsw'
| 'pmaxub'
| 'pminsw'
| 'pminub'
| 'pmovmskb'
| 'pmulhuw'
| 'pmulhw'
| 'pmullw'
| 'pmuludq'
| 'pop'
| 'popa'
| 'popad'
| 'popf'
| 'popfd'
| 'por'
| 'prefetchnta'
| 'prefetcht0'
| 'prefetcht1'
| 'prefetcht2'
| 'psadbw'
| 'pshufd'
| 'pshufhw'
| 'pshuflw'
| 'pshufw'
| 'pslld'
| 'pslldq'
| 'psllq'
| 'psllw'
| 'psrad'
| 'psraw'
| 'psrld'
| 'psrldq'
| 'psrlq'
| 'psrlw'
| 'psubb'
| 'psubd'
| 'psubq'
| 'psubsb'
| 'psubsw'
| 'psubusb'
| 'psubusw'
| 'psubw'
| 'punpckhbw'
| 'punpckhdq'
| 'punpckhqdq'
| 'punpckhwd'
| 'punpcklbw'
| 'punpckldq'
| 'punpcklqdq'
| 'punpcklwd'
| 'push'
| 'pusha'
| 'pushad'
| 'pushf'
| 'pushfd'
| 'pxor'
| 'rcl'
| 'rcpps'
| 'rcpss'
| 'rcr'
| 'rdmsr'
| 'rdpmc'
| 'rdtsc'
| 'rep'
| 'repe'
| 'repne'
| 'repnz'
| 'repz'
| 'ret'
| 'retf'
| 'rol'
| 'ror'
| 'rsm'
| 'rsqrtps'
| 'rsqrtss'
| 'sahf'
| 'sal'
| 'sar'
| 'sbb'
| 'scas'
| 'scasb'
| 'scasd'
| 'scasw'
| 'seta'
| 'setae'
| 'setb'
| 'setbe'
| 'setc'
| 'sete'
| 'setg'
| 'setge'
| 'setl'
| 'setle'
| 'setna'
| 'setnae'
| 'setnb'
| 'setnbe'
| 'setnc'
| 'setne'
| 'setng'
| 'setnge'
| 'setnl'
| 'setnle'
| 'setno'
| 'setnp'
| 'setns'
| 'setnz'
| 'seto'
| 'setp'
| 'setpe'
| 'setpo'
| 'sets'
| 'setz'
| 'sfence'
| 'sgdt'
| 'shl'
| 'shld'
| 'shr'
| 'shrd'
| 'shufpd'
| 'shufps'
| 'sidt'
| 'sldt'
| 'smsw'
| 'sqrtpd'
| 'sqrtps'
| 'sqrtsd'
| 'sqrtss'
| 'stc'
| 'std'
| 'sti'
| 'stmxcsr'
| 'stos'
| 'stosb'
| 'stosd'
| 'stosw'
| 'str'
| 'sub'
| 'subpd'
| 'subps'
| 'subsd'
| 'subss'
| 'sysenter'
| 'sysexit'
| 'test'
| 'ucomisd'
| 'ucomiss'
| 'ud2'
| 'unpckhpd'
| 'unpckhps'
| 'unpcklpd'
| 'unpcklps'
| 'verr'
| 'verw'
| 'wait'
| 'wbinvd'
| 'wrmsr'
| 'xadd'
| 'xchg'
| 'xlat'
| 'xlatb'
| 'xor'
| 'xorpd'
| 'xorps'
| 'addsubpd'
| 'addsubps'
| 'fisttp'
| 'haddpd'
| 'haddps'
| 'hsubpd'
| 'hsubps'
| 'lddqu'
| 'monitor'
| 'movddup'
| 'movshdup'
| 'movsldup'
| 'mwait'
| 'pavgusb'
| 'pf2id'
| 'pfacc'
| 'pfadd'
| 'pfcmpeq'
| 'pfcmpge'
| 'pfcmpgt'
| 'pfmax'
| 'pfmin'
| 'pfmul'
| 'pfnacc'
| 'pfpnacc'
| 'pfrcp'
| 'pfrcpit1'
| 'pfrcpit2'
| 'pfrsqit1'
| 'pfrsqrt'
| 'pfsub'
| 'pfsubr'
| 'pi2fd'
| 'pmulhrw'
| 'pswapd'

Declaration ::=
    EnumDeclaration
   | FuncDeclaration
   | VarDeclarations //must come before alias decleration
   | AliasDeclaration
   | AggregateDeclaration
   | ImportDeclaration
   | TemplateDeclaration

AliasDeclaration ::=
  'alias' Identifier '=' Type TemplateArguments? ';'
  | 'alias' Identifier '=' Initializer ';'
  | 'alias' StorageClasses? BasicType (FuncDeclarator|Declarator) ';'
  | 'alias' AliasDeclarationX ';'{
     methods=[getName getFullName getNameIdentifier getReference setName getPresentation isSomeVisibility actuallyIsDeclaration getDeclarationType]
     stubClass="net.masterthought.dlanguage.stubs.DLanguageAliasDeclarationStub"
     implements=["net.masterthought.dlanguage.psi.interfaces.DNamedElement" "net.masterthought.dlanguage.psi.interfaces.HasVisibility" "net.masterthought.dlanguage.psi.interfaces.Declaration"]
}

AliasDeclarationX ::=
    AliasDeclarationY [',' AliasDeclarationX]

AliasDeclarationY ::=
    Identifier TemplateParameters? '=' ( StorageClasses? Type | FunctionLiteral)

AutoDeclaration ::=
    StorageClasses? AutoDeclarationX ';'

AutoDeclarationX ::=
    AutoDeclarationY [',' AutoDeclarationX]

AutoDeclarationY ::=
    Identifier TemplateParameters? '=' Initializer{
        methods = [getName getFullName getNameIdentifier getReference setName getPresentation isSomeVisibility actuallyIsDeclaration getVariableDeclarationType]
        stubClass="net.masterthought.dlanguage.stubs.DLanguageAutoDeclarationStub"
        implements = ["net.masterthought.dlanguage.psi.interfaces.DNamedElement" "net.masterthought.dlanguage.psi.interfaces.VariableDeclaration" "net.masterthought.dlanguage.psi.interfaces.Declaration"]
    }

VarDeclarations ::=
    StorageClasses? BasicType? Declarators ';'
    | AutoDeclaration

Declarators ::=
    DeclaratorInitializer (',' DeclaratorIdentifierList)?

DeclaratorInitializer ::=
    AltDeclarator ('=' Initializer)?
    | VarDeclarator (TemplateParameters? '=' Initializer)?{
        methods=[ getName getFullName getNameIdentifier getReference setName getPresentation isSomeVisibility actuallyIsDeclaration getVariableDeclarationType]
        stubClass="net.masterthought.dlanguage.stubs.DLanguageDeclaratorInitializerStub"
        implements = ["net.masterthought.dlanguage.psi.interfaces.DNamedElement" "net.masterthought.dlanguage.psi.interfaces.VariableDeclaration" "net.masterthought.dlanguage.psi.interfaces.Declaration"]
    }


DeclaratorIdentifierList ::=
    DeclaratorIdentifier [',' DeclaratorIdentifierList]

DeclaratorIdentifier ::=
    VarDeclaratorIdentifier
    | AltDeclaratorIdentifier

VarDeclaratorIdentifier ::=
    Identifier TemplateParameters? '=' Initializer

AltDeclaratorIdentifier ::=
    BasicType2? Identifier AltDeclaratorSuffixes? ('=' Initializer)?

Declarator ::=
    VarDeclarator
    | AltDeclarator

VarDeclarator ::=
    BasicType2? Identifier

AltDeclarator ::=
    BasicType2? Identifier AltDeclaratorSuffixes
    | BasicType2? '(' AltDeclaratorX ')' AltFuncDeclaratorSuffix? AltDeclaratorSuffixes?

AltDeclaratorX ::=
    BasicType2? Identifier AltFuncDeclaratorSuffix?
    | AltDeclarator

AltDeclaratorSuffixes ::=
    AltDeclaratorSuffix [AltDeclaratorSuffixes]

AltDeclaratorSuffix ::=
    '[' (AssignExpression | Type)? ']'

AltFuncDeclaratorSuffix ::=
    Parameters MemberFunctionAttributes?

StorageClasses ::=
    StorageClass [StorageClasses]

StorageClass ::=
    LinkageAttribute
    | AlignAttribute
    | 'deprecated'
    | 'enum'
    | 'static'
    | 'extern'
    | 'abstract'
    | 'final'
    | 'override'
    | 'synchronized'
    | 'auto'
    | 'scope'
    | 'const'
    | 'immutable'
    | 'inout'
    | 'shared'
    | '__gshared'
    | Property
    | 'nothrow'
    | 'pure'
    | 'ref'

Initializer ::=
    VoidInitializer
    | NonVoidInitializer

VoidInitializer ::=
    'void'

NonVoidInitializer ::=
    AssignExpression
    | ArrayInitializer
    | StructInitializer

ArrayInitializer ::=
    '[' ArrayMemberInitializations? ','? ']'


ArrayMemberInitializations ::=
    ArrayMemberInitialization [(',')? ArrayMemberInitializations]

ArrayMemberInitialization ::=
    NonVoidInitializer [':' NonVoidInitializer]

StructInitializer ::=
    '{' StructMemberInitializers? '}'

StructMemberInitializers ::=
    StructMemberInitializer (',' StructMemberInitializers)?

StructMemberInitializer ::=
 NonVoidInitializer [':' NonVoidInitializer]

//Function

FuncDeclaration ::=
    StorageClasses? BasicType FuncDeclarator (FunctionBody |';'| '=')?
    | AutoFuncDeclaration {
      methods=[getName getFullName getNameIdentifier getReference setName getPresentation getArguments isSomeVisibility getTemplateArguments getProtection getArguments isSystem isNoGC isTrusted hasCustomProperty isSafe getCustomProperty isPropertyFunction]
      implements = ["net.masterthought.dlanguage.psi.interfaces.containers.StatementContainer" "net.masterthought.dlanguage.psi.interfaces.DNamedElement" "net.masterthought.dlanguage.psi.interfaces.HasVisibility" "net.masterthought.dlanguage.psi.interfaces.HasProperty" "net.masterthought.dlanguage.psi.interfaces.HasTemplateArguments" "net.masterthought.dlanguage.psi.interfaces.HasArguments" "net.masterthought.dlanguage.psi.interfaces.Declaration"]
      stubClass="net.masterthought.dlanguage.stubs.DLanguageFuncDeclarationStub"
    }

private AutoFuncDeclaration ::=
    StorageClasses Identifier FuncDeclaratorSuffix FunctionBody?

private FuncDeclarator ::=
    BasicType2? Identifier FuncDeclaratorSuffix

FuncDeclaratorSuffix ::=
     TemplateParameters? Parameters MemberFunctionAttributes? Constraint?
     | Parameters MemberFunctionAttributes?

Parameters ::=
    '(' ParameterList? ')'

ParameterList ::=
    Parameter (',' ParameterList)?
    | '...'

Parameter ::=
       InOut? BasicType Declarator ('...' | '=' AssignExpression)?
       | InOut? Type ('...')?

InOut ::=
    InOutX [InOut]

InOutX ::=
    'auto'
    | TypeCtor
    | 'final'
    | 'in'
    | 'lazy'
    | 'out'
    | 'ref'
    | 'scope'
    | 'return ref'

FunctionAttributes ::=
    FunctionAttribute [FunctionAttributes]

FunctionAttribute ::=
    'nothrow'
    | 'pure'
    | Property

MemberFunctionAttributes ::=
  MemberFunctionAttribute [MemberFunctionAttributes]

MemberFunctionAttribute ::=
    'const'
    | 'immutable'
    | 'inout'
    | 'shared'
    | 'return'
    | FunctionAttribute

FunctionBody ::=
    BlockStatement
   | FunctionContracts? BodyStatement


FunctionContracts ::=
    InStatement OutStatement?
    | OutStatement InStatement?

InStatement ::=
    'in' BlockStatement

OutStatement ::=
    'out' BlockStatement
    | 'out' '(' Identifier ')' BlockStatement

BodyStatement ::=
    'body' BlockStatement

Constructor ::=
    'this' Parameters MemberFunctionAttributes? ';'
    | 'this' Parameters MemberFunctionAttributes? FunctionBody
    | ConstructorTemplate {
         methods=[getName getFullName getNameIdentifier getReference setName getPresentation isSomeVisibility getArguments ]
         implements = ["net.masterthought.dlanguage.psi.interfaces.containers.StatementContainer" "net.masterthought.dlanguage.psi.interfaces.DNamedElement" "net.masterthought.dlanguage.psi.interfaces.HasVisibility" "net.masterthought.dlanguage.psi.interfaces.HasTemplateArguments" "net.masterthought.dlanguage.psi.interfaces.HasArguments" "net.masterthought.dlanguage.psi.interfaces.Declaration"]
         stubClass="net.masterthought.dlanguage.stubs.DLanguageConstructorStub"
    }

ConstructorTemplate ::=
    'this' TemplateParameters Parameters MemberFunctionAttributes? Constraint? ';'
    | 'this' TemplateParameters Parameters MemberFunctionAttributes? Constraint? FunctionBody

Destructor ::=
    '~' 'this' '(' ')' MemberFunctionAttributes? ';'
    | '~' 'this' '(' ')' MemberFunctionAttributes? FunctionBody{
        methods=[getName getFullName getNameIdentifier getReference setName getPresentation isSomeVisibility]
        implements = ["net.masterthought.dlanguage.psi.interfaces.containers.StatementContainer" "net.masterthought.dlanguage.psi.interfaces.DNamedElement" "net.masterthought.dlanguage.psi.interfaces.HasVisibility" "net.masterthought.dlanguage.psi.interfaces.Declaration"]
        stubClass="net.masterthought.dlanguage.stubs.DLanguageDestructorStub"
   }

Postblit ::=
    'this' '(' 'this' ')' MemberFunctionAttributes? ';'
    | 'this' '(' 'this' ')' MemberFunctionAttributes? FunctionBody

Allocator ::=
    'new' Parameters ';'
    | 'new' Parameters FunctionBody

Deallocator ::=
    'delete' Parameters ';'
    | 'delete' Parameters FunctionBody

Invariant ::=
    'invariant' '(' ')' BlockStatement
    | 'invariant' BlockStatement

UnitTesting ::=
    'unittest' BlockStatement{
    implements = ["net.masterthought.dlanguage.psi.interfaces.DCompositeElement"]
    extends = "net.masterthought.dlanguage.psi.impl.DStubBasedPsiElementBase<net.masterthought.dlanguage.stubs.interfaces.UnitTestingStub>"
    stubClass="net.masterthought.dlanguage.stubs.interfaces.UnitTestingStub"
    }

StaticConstructor ::=
    'static' 'this' '(' ')' ';'
    | 'static' 'this' '(' ')' FunctionBody{
       methods=[getName getFullName getNameIdentifier getReference setName getPresentation isSomeVisibility ]
       implements = ["net.masterthought.dlanguage.psi.interfaces.containers.StatementContainer" "net.masterthought.dlanguage.psi.interfaces.DNamedElement" "net.masterthought.dlanguage.psi.interfaces.HasVisibility" "net.masterthought.dlanguage.psi.interfaces.Declaration" ]
       stubClass="net.masterthought.dlanguage.stubs.DLanguageStaticConstructorStub"
   }

StaticDestructor ::=
    'static' '~' 'this' '(' ')' MemberFunctionAttributes? ';'
    | 'static' '~' 'this' '(' ')' MemberFunctionAttributes? FunctionBody{
       methods=[getName getFullName getNameIdentifier getReference setName getPresentation isSomeVisibility]
       implements = ["net.masterthought.dlanguage.psi.interfaces.containers.StatementContainer" "net.masterthought.dlanguage.psi.interfaces.DNamedElement" "net.masterthought.dlanguage.psi.interfaces.HasVisibility" "net.masterthought.dlanguage.psi.interfaces.Declaration"]
       stubClass="net.masterthought.dlanguage.stubs.DLanguageStaticDestructorStub"
    }

SharedStaticConstructor ::=
    'shared' 'static' 'this' '(' ')' ';'
    | 'shared' 'static' 'this' '(' ')' FunctionBody{
      methods=[getName getFullName getNameIdentifier getReference setName getPresentation isSomeVisibility ]
      implements = ["net.masterthought.dlanguage.psi.interfaces.containers.StatementContainer" "net.masterthought.dlanguage.psi.interfaces.DNamedElement" "net.masterthought.dlanguage.psi.interfaces.HasVisibility" "net.masterthought.dlanguage.psi.interfaces.Declaration" ]
      stubClass="net.masterthought.dlanguage.stubs.DLanguageSharedStaticConstructorStub"
  }
SharedStaticDestructor ::=
    'shared' 'static' '~' 'this' '(' ')' MemberFunctionAttributes? ';'
    | 'shared' 'static' '~' 'this' '(' ')' MemberFunctionAttributes? FunctionBody{
       methods=[getName getFullName getNameIdentifier getReference setName getPresentation isSomeVisibility]
       implements = ["net.masterthought.dlanguage.psi.interfaces.containers.StatementContainer" "net.masterthought.dlanguage.psi.interfaces.DNamedElement" "net.masterthought.dlanguage.psi.interfaces.HasVisibility" "net.masterthought.dlanguage.psi.interfaces.Declaration"]
       stubClass="net.masterthought.dlanguage.stubs.DLanguageSharedStaticDestructorStub"
   }

// Aggregate

AggregateDeclaration ::=
    ClassDeclaration
    | InterfaceDeclaration
    | StructDeclaration
    | UnionDeclaration

ClassDeclaration ::=
    'class' Identifier ';'
    | 'class' Identifier BaseClassList? AggregateBody
    | ClassTemplateDeclaration {
       methods=[getName getFullName getNameIdentifier getReference setName getPresentation isSomeVisibility getProtection whatInheritsFrom getSuperClassNames]
       implements = ["net.masterthought.dlanguage.psi.interfaces.containers.StatementContainer" "net.masterthought.dlanguage.psi.interfaces.containers.MixinContainer" "net.masterthought.dlanguage.psi.interfaces.DNamedElement" "net.masterthought.dlanguage.psi.interfaces.HasVisibility" "net.masterthought.dlanguage.psi.interfaces.HasTemplateArguments" "net.masterthought.dlanguage.psi.interfaces.CanInherit" "net.masterthought.dlanguage.psi.interfaces.Declaration"]
       stubClass="net.masterthought.dlanguage.stubs.DLanguageClassDeclarationStub"
       }

ClassTemplateDeclaration ::=
    'class' Identifier TemplateParameters Constraint? BaseClassList? AggregateBody
    | 'class' Identifier TemplateParameters BaseClassList Constraint AggregateBody

InterfaceDeclaration ::=
    'interface' Identifier ';'
    | InterfaceTemplateDeclaration
    | 'interface' Identifier BaseInterfaceList? AggregateBody?{
        methods=[getName getFullName getNameIdentifier getReference setName getPresentation isSomeVisibility whatInheritsFrom getTemplateArguments getSuperClassNames]
       implements = ["net.masterthought.dlanguage.psi.interfaces.containers.StatementContainer" "net.masterthought.dlanguage.psi.interfaces.DNamedElement" "net.masterthought.dlanguage.psi.interfaces.containers.MixinContainer" "net.masterthought.dlanguage.psi.interfaces.HasVisibility" "net.masterthought.dlanguage.psi.interfaces.HasTemplateArguments" "net.masterthought.dlanguage.psi.interfaces.CanInherit" "net.masterthought.dlanguage.psi.interfaces.Declaration"]
       stubClass="net.masterthought.dlanguage.stubs.DLanguageInterfaceDeclarationStub"
    }


InterfaceTemplateDeclaration ::=
      'interface' Identifier TemplateParameters Constraint? BaseInterfaceList? AggregateBody

StructDeclaration ::=
    'struct' Identifier? TemplateParameters? Constraint? (AggregateBody | ';')?{
      methods=[getName getFullName getNameIdentifier getReference setName getPresentation isSomeVisibility getTemplateArguments]
    implements = ["net.masterthought.dlanguage.psi.interfaces.containers.StatementContainer" "net.masterthought.dlanguage.psi.interfaces.DNamedElement" "net.masterthought.dlanguage.psi.interfaces.containers.MixinContainer" "net.masterthought.dlanguage.psi.interfaces.HasVisibility" "net.masterthought.dlanguage.psi.interfaces.HasTemplateArguments" "net.masterthought.dlanguage.psi.interfaces.Declaration"]
    stubClass="net.masterthought.dlanguage.stubs.DLanguageStructDeclarationStub"
   }

UnionDeclaration ::=
    'union' Identifier ';'
    | 'union' Identifier AggregateBody
    | UnionTemplateDeclaration
    | AnonUnionDeclaration{
        methods = [getName getFullName getNameIdentifier getReference setName getPresentation isSomeVisibility getTemplateArguments]
        implements = ["net.masterthought.dlanguage.psi.interfaces.containers.StatementContainer" "net.masterthought.dlanguage.psi.interfaces.DNamedElement" "net.masterthought.dlanguage.psi.interfaces.HasVisibility" "net.masterthought.dlanguage.psi.interfaces.HasTemplateArguments" "net.masterthought.dlanguage.psi.interfaces.Declaration"]
         stubClass="net.masterthought.dlanguage.stubs.DLanguageUnionDeclarationStub"
    }

UnionTemplateDeclaration ::=
    'union' Identifier TemplateParameters Constraint? AggregateBody

AnonUnionDeclaration ::=
    'union' AggregateBody

AggregateBody ::=
    '{' DeclDefs? '}'

BaseClassList ::=
    ':' SuperClass (',' Interfaces)?
    | ':' Interfaces

BaseInterfaceList ::=
    ':' Interfaces

SuperClass ::=
    BasicType

Interfaces ::=
    Interface (',' Interfaces)?

Interface ::=
    BasicType

AliasThis ::=
    'alias' Identifier 'this' ';'

// Enum

//EnumBody ::=
//     '{' EnumMember (',' EnumMember?)* '}'
//
// AnonymousEnumMember ::=
//       Type? Identifier ('=' AssignExpression)?
//
// AnonymousEnumDeclaration ::=
//     'enum' (':' Type)? '{' AnonymousEnumMember? '}'
//
// EnumDeclaration ::=
//       'enum' Identifier (':' Type)? EnumBody? ';'
//     | AnonymousEnumDeclaration
//
//
// EnumMember ::=
//      Identifier? '=' AssignExpression

EnumDeclaration ::=
    'enum' Identifier (':' EnumBaseType)? EnumBody
    | AnonymousEnumDeclaration{
      methods = [getName getFullName getNameIdentifier getReference setName getPresentation isSomeVisibility]
      implements = ["net.masterthought.dlanguage.psi.interfaces.DNamedElement" "net.masterthought.dlanguage.psi.interfaces.HasVisibility" "net.masterthought.dlanguage.psi.interfaces.Declaration"]
       stubClass="net.masterthought.dlanguage.stubs.DLanguageEnumDeclarationStub"
  }

EnumBaseType ::=
    Type

EnumBody ::=
    '{' EnumMembers ','? '}'

EnumMembers ::=
    EnumMember [',' EnumMembers]

EnumMember ::= Identifier ('=' AssignExpression)? | Type Identifier '=' AssignExpression

AnonymousEnumDeclaration ::=
    'enum' (':' EnumBaseType)? ('{' (EnumMembers) '}')?

//Template

TemplateDeclaration ::=
    'template' Identifier TemplateParameters Constraint? '{' DeclDefs? '}' {
      methods=[getName getFullName getNameIdentifier getReference setName getPresentation getTemplateArguments isSomeVisibility ]
    implements = ["net.masterthought.dlanguage.psi.interfaces.DNamedElement" "net.masterthought.dlanguage.psi.interfaces.containers.StatementContainer" "net.masterthought.dlanguage.psi.interfaces.containers.MixinContainer" "net.masterthought.dlanguage.psi.interfaces.containers.GlobalDeclarationContainer" "net.masterthought.dlanguage.psi.interfaces.HasVisibility" "net.masterthought.dlanguage.psi.interfaces.HasTemplateArguments" "net.masterthought.dlanguage.psi.interfaces.Mixinable" "net.masterthought.dlanguage.psi.interfaces.Declaration"]
      stubClass="net.masterthought.dlanguage.stubs.DLanguageTemplateDeclarationStub"
    }

TemplateParameters ::=
    '(' TemplateParameterList? ')'

TemplateParameterList ::=
    TemplateParameter [',' TemplateParameterList]

Constraint ::=
    'if' '(' Expression ')'

TemplateInstance ::=
    Identifier? TemplateArguments

TemplateArguments ::=
     '!' ('(' TemplateArgumentList? ')') | '!' TemplateSingleArgument

TemplateArgumentList ::=
    TemplateArgument (',' TemplateArgumentList?)?

TemplateArgument ::=
    Type
    | AssignExpression
    | Symbol

Symbol ::=
    ('.')? SymbolTail

SymbolTail ::=
    (Identifier | TemplateInstance) ['.' SymbolTail]

TemplateSingleArgument ::=
    Identifier
    | BasicTypeX
    | CHARACTER_LITERAL
    | StringLiteral
    | INTEGER_LITERAL
    | FLOAT_LITERAL
    | 'true'
    | 'false'
    | 'null'
    | 'this'
    | SpecialKeyword


 TemplateParameter ::=
     TemplateTypeParameter
     | TemplateAliasParameter
     | TemplateThisParameter

 TemplateTypeParameter ::=
     Type Identifier? '...'? [(':' Type)? ('=' Type)?] [(':' AssignExpression)? TemplateValueParameterDefault?]

TemplateAliasParameter ::=
     'alias' Type? Identifier? (':' (Type | AssignExpression))? ('=' (Type | AssignExpression))?

TemplateThisParameter ::=
    'this' TemplateTypeParameter

TemplateValueParameterDefault ::=
    '=' ( AssignExpression | SpecialKeyword)

TemplateMixinDeclaration ::=
    'mixin' 'template' Identifier TemplateParameters Constraint? '{' DeclDefs? '}'{
        methods=[getName getFullName getNameIdentifier getReference setName getPresentation isSomeVisibility ]//getTemplateArguments getPublicSyTypesmbols]
    implements = ["net.masterthought.dlanguage.psi.interfaces.DNamedElement" "net.masterthought.dlanguage.psi.interfaces.containers.StatementContainer" "net.masterthought.dlanguage.psi.interfaces.containers.MixinContainer" "net.masterthought.dlanguage.psi.interfaces.containers.GlobalDeclarationContainer" "net.masterthought.dlanguage.psi.interfaces.HasVisibility" "net.masterthought.dlanguage.psi.interfaces.HasTemplateArguments" "net.masterthought.dlanguage.psi.interfaces.Mixinable" "net.masterthought.dlanguage.psi.interfaces.Declaration"]
        stubClass="net.masterthought.dlanguage.stubs.DLanguageTemplateMixinDeclarationStub"
    }

TemplateMixin ::=
    'mixin' MixinTemplateName TemplateArguments? Identifier? ';'{
        methods = [ getName ]
        implements = ["net.masterthought.dlanguage.psi.interfaces.Mixin"]
    }

MixinTemplateName ::=
    Typeof? '.'? QualifiedIdentifierList

QualifiedIdentifierList ::=
    (Identifier | TemplateInstance) [ '.' QualifiedIdentifierList ]

//Attribute
AttributeSpecifier ::=
    Attribute (':' | DeclarationBlock)

Attribute ::=
    LinkageAttribute
    | AlignAttribute
    | DeprecatedAttribute
    | ProtectionAttribute
    | Pragma
    | 'static'
    | 'extern'
    | 'abstract'
    | 'final'
    | 'override'
    | 'synchronized'
    | 'auto'
    | 'scope'
    | 'const'
    | 'immutable'
    | 'inout'
    | 'shared'
    | '__gshared'
    | Property
    | 'nothrow'
    | 'pure'
    | 'ref'

DeclarationBlock ::=
    DeclDef
    | '{' DeclDefs? '}'

LinkageAttribute ::=
    'extern' '(' LinkageType ')'
    | 'extern' '(' Identifier '++' (',' IdentifierList)? ')'

LinkageType ::=
     'C'
    | Identifier '++'
    | 'D'
    | 'Windows'
    | 'Pascal'
    | 'System'
    | 'Objective-C'

AlignAttribute ::=
    'align' ('(' INTEGER_LITERAL ')')?

DeprecatedAttribute ::=
    'deprecated' ('(' StringLiteral ')')?

ProtectionAttribute ::=
     'private'
    | 'package'
    | 'package' '(' IdentifierList ')'
    | 'protected'
    | 'public'
    | 'export'

Property ::=
    '@' PropertyIdentifier
    | UserDefinedAttribute

PropertyIdentifier ::=
     'property'
    | 'safe'
    | 'trusted'
    | 'system'
    | 'disable'
    | 'nogc'

UserDefinedAttribute ::=
      '@' '(' ArgumentList ')'
    | '@' Identifier ('(' ArgumentList? ')')?
    | '@' TemplateInstance ('(' ArgumentList? ')')?

Pragma ::=
    'pragma' '(' Identifier (',' ArgumentList)? ')'

//Conditional

ConditionalDeclaration ::=
    Condition DeclarationBlock ('else' DeclarationBlock)?
    | Condition ':' DeclDefs?
    | Condition DeclarationBlock 'else' ':' DeclDefs?

ConditionalStatement ::=
    Condition Statement ('else' Statement)?

Condition ::=
    VersionCondition
    | DebugCondition
    | StaticIfCondition

VersionCondition ::=
    'version' '(' (INTEGER_LITERAL | Identifier | 'unittest' | 'assert') ')'

DebugCondition ::=
    'debug' ('(' (INTEGER_LITERAL | Identifier) ')')?

StaticIfCondition ::=
    'static' 'if' '(' AssignExpression ')'

StaticElseCondition ::= 'else'

VersionSpecification ::=
    'version' '=' (Identifier | INTEGER_LITERAL) ';'

DebugSpecification ::=
   'debug' '=' (Identifier | INTEGER_LITERAL) ';'

StaticAssert ::=
    'static' 'assert' '(' AssignExpression (',' AssignExpression)? ')' ';'
//    | 'static' 'assert' '(' TraitsExpression ')'' ;'

